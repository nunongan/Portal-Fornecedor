!function (t) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else { var e; (e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).Chart = t() } }(function () { return (function t(e, i, n) { function o(s, l) { if (!i[s]) { if (!e[s]) { var u = "function" == typeof require && require; if (!l && u) return u(s, !0); if (a) return a(s, !0); var c = Error("Cannot find module '" + s + "'"); throw c.code = "MODULE_NOT_FOUND", c } var d = i[s] = { exports: {} }; e[s][0].call(d.exports, function (t) { var i; return o(e[s][1][t] || t) }, d, d.exports, t, e, i, n) } return i[s].exports } for (var a = "function" == typeof require && require, s = 0; s < n.length; s++)o(n[s]); return o })({ 1: [function (t, e, i) { }, {}], 2: [function (t, e, i) { function n(t) { if (t) { var e = /^#([a-fA-F0-9]{3})$/, i = [0, 0, 0], n = 1, o = t.match(e); if (o) { o = o[1]; for (var a = 0; a < i.length; a++)i[a] = parseInt(o[a] + o[a], 16) } else if (o = t.match(/^#([a-fA-F0-9]{6})$/)) { o = o[1]; for (var a = 0; a < i.length; a++)i[a] = parseInt(o.slice(2 * a, 2 * a + 2), 16) } else if (o = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/)) { for (var a = 0; a < i.length; a++)i[a] = parseInt(o[a + 1]); n = parseFloat(o[4]) } else if (o = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/)) { for (var a = 0; a < i.length; a++)i[a] = Math.round(2.55 * parseFloat(o[a + 1])); n = parseFloat(o[4]) } else if (o = t.match(/(\w+)/)) { if ("transparent" == o[1]) return [0, 0, 0, 0]; if (!(i = h[o[1]])) return } for (var a = 0; a < i.length; a++)i[a] = c(i[a], 0, 255); return n = n || 0 == n ? c(n, 0, 1) : 1, i[3] = n, i } } function o(t) { if (t) { var e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { var i = parseFloat(e[4]), n = c(parseInt(e[1]), 0, 360), o = c(parseFloat(e[2]), 0, 100), a = c(parseFloat(e[3]), 0, 100), s = c(isNaN(i) ? 1 : i, 0, 1); return [n, o, a, s] } } } function a(t) { if (t) { var e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { var i = parseFloat(e[4]), n = c(parseInt(e[1]), 0, 360), o = c(parseFloat(e[2]), 0, 100), a = c(parseFloat(e[3]), 0, 100), s = c(isNaN(i) ? 1 : i, 0, 1); return [n, o, a, s] } } } function s(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")" } function l(t, e) { var i, n = Math.round(t[0] / 255 * 100); return "rgba(" + n + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")" } function u(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")" } function c(t, e, i) { return Math.min(Math.max(e, t), i) } function d(t) { var e = t.toString(16).toUpperCase(); return e.length < 2 ? "0" + e : e } var h = t(6); e.exports = { getRgba: n, getHsla: o, getRgb: function t(e) { var i = n(e); return i && i.slice(0, 3) }, getHsl: function t(e) { var i = o(e); return i && i.slice(0, 3) }, getHwb: a, getAlpha: function t(e) { var i = n(e); return i ? i[3] : (i = o(e)) ? i[3] : (i = a(e)) ? i[3] : void 0 }, hexString: function t(e) { return "#" + d(e[0]) + d(e[1]) + d(e[2]) }, rgbString: function t(e, i) { return i < 1 || e[3] && e[3] < 1 ? s(e, i) : "rgb(" + e[0] + ", " + e[1] + ", " + e[2] + ")" }, rgbaString: s, percentString: function t(e, i) { if (i < 1 || e[3] && e[3] < 1) return l(e, i); var n, o = Math.round(e[0] / 255 * 100); return "rgb(" + o + "%, " + Math.round(e[1] / 255 * 100) + "%, " + Math.round(e[2] / 255 * 100) + "%)" }, percentaString: l, hslString: function t(e, i) { return i < 1 || e[3] && e[3] < 1 ? u(e, i) : "hsl(" + e[0] + ", " + e[1] + "%, " + e[2] + "%)" }, hslaString: u, hwbString: function t(e, i) { return void 0 === i && (i = void 0 !== e[3] ? e[3] : 1), "hwb(" + e[0] + ", " + e[1] + "%, " + e[2] + "%" + (void 0 !== i && 1 !== i ? ", " + i : "") + ")" }, keyword: function t(e) { return f[e.slice(0, 3)] } }; var f = {}; for (var p in h) f[h[p]] = p }, { 6: 6 },], 3: [function (t, e, i) { var n = t(5), o = t(2), a = function (t) { var e; if (t instanceof a) return t; if (!(this instanceof a)) return new a(t); if (this.values = { rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1 }, "string" == typeof t) { if (e = o.getRgba(t)) this.setValues("rgb", e); else if (e = o.getHsla(t)) this.setValues("hsl", e); else { if (!(e = o.getHwb(t))) throw Error('Unable to parse color from string "' + t + '"'); this.setValues("hwb", e) } } else if ("object" == typeof t) { if (void 0 !== (e = t).r || void 0 !== e.red) this.setValues("rgb", e); else if (void 0 !== e.l || void 0 !== e.lightness) this.setValues("hsl", e); else if (void 0 !== e.v || void 0 !== e.value) this.setValues("hsv", e); else if (void 0 !== e.w || void 0 !== e.whiteness) this.setValues("hwb", e); else { if (void 0 === e.c && void 0 === e.cyan) throw Error("Unable to parse color from object " + JSON.stringify(t)); this.setValues("cmyk", e) } } }; a.prototype = { rgb: function () { return this.setSpace("rgb", arguments) }, hsl: function () { return this.setSpace("hsl", arguments) }, hsv: function () { return this.setSpace("hsv", arguments) }, hwb: function () { return this.setSpace("hwb", arguments) }, cmyk: function () { return this.setSpace("cmyk", arguments) }, rgbArray: function () { return this.values.rgb }, hslArray: function () { return this.values.hsl }, hsvArray: function () { return this.values.hsv }, hwbArray: function () { var t = this.values; return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb }, cmykArray: function () { return this.values.cmyk }, rgbaArray: function () { var t = this.values; return t.rgb.concat([t.alpha]) }, hslaArray: function () { var t = this.values; return t.hsl.concat([t.alpha]) }, alpha: function (t) { return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this) }, red: function (t) { return this.setChannel("rgb", 0, t) }, green: function (t) { return this.setChannel("rgb", 1, t) }, blue: function (t) { return this.setChannel("rgb", 2, t) }, hue: function (t) { return t && (t %= 360, t = t < 0 ? 360 + t : t), this.setChannel("hsl", 0, t) }, saturation: function (t) { return this.setChannel("hsl", 1, t) }, lightness: function (t) { return this.setChannel("hsl", 2, t) }, saturationv: function (t) { return this.setChannel("hsv", 1, t) }, whiteness: function (t) { return this.setChannel("hwb", 1, t) }, blackness: function (t) { return this.setChannel("hwb", 2, t) }, value: function (t) { return this.setChannel("hsv", 2, t) }, cyan: function (t) { return this.setChannel("cmyk", 0, t) }, magenta: function (t) { return this.setChannel("cmyk", 1, t) }, yellow: function (t) { return this.setChannel("cmyk", 2, t) }, black: function (t) { return this.setChannel("cmyk", 3, t) }, hexString: function () { return o.hexString(this.values.rgb) }, rgbString: function () { return o.rgbString(this.values.rgb, this.values.alpha) }, rgbaString: function () { return o.rgbaString(this.values.rgb, this.values.alpha) }, percentString: function () { return o.percentString(this.values.rgb, this.values.alpha) }, hslString: function () { return o.hslString(this.values.hsl, this.values.alpha) }, hslaString: function () { return o.hslaString(this.values.hsl, this.values.alpha) }, hwbString: function () { return o.hwbString(this.values.hwb, this.values.alpha) }, keyword: function () { return o.keyword(this.values.rgb, this.values.alpha) }, rgbNumber: function () { var t = this.values.rgb; return t[0] << 16 | t[1] << 8 | t[2] }, luminosity: function () { for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) { var n = t[i] / 255; e[i] = n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4) } return .2126 * e[0] + .7152 * e[1] + .0722 * e[2] }, contrast: function (t) { var e = this.luminosity(), i = t.luminosity(); return e > i ? (e + .05) / (i + .05) : (i + .05) / (e + .05) }, level: function (t) { var e = this.contrast(t); return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : "" }, dark: function () { var t = this.values.rgb; return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128 }, light: function () { return !this.dark() }, negate: function () { for (var t = [], e = 0; e < 3; e++)t[e] = 255 - this.values.rgb[e]; return this.setValues("rgb", t), this }, lighten: function (t) { var e = this.values.hsl; return e[2] += e[2] * t, this.setValues("hsl", e), this }, darken: function (t) { var e = this.values.hsl; return e[2] -= e[2] * t, this.setValues("hsl", e), this }, saturate: function (t) { var e = this.values.hsl; return e[1] += e[1] * t, this.setValues("hsl", e), this }, desaturate: function (t) { var e = this.values.hsl; return e[1] -= e[1] * t, this.setValues("hsl", e), this }, whiten: function (t) { var e = this.values.hwb; return e[1] += e[1] * t, this.setValues("hwb", e), this }, blacken: function (t) { var e = this.values.hwb; return e[2] += e[2] * t, this.setValues("hwb", e), this }, greyscale: function () { var t = this.values.rgb, e = .3 * t[0] + .59 * t[1] + .11 * t[2]; return this.setValues("rgb", [e, e, e]), this }, clearer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e - e * t), this }, opaquer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e + e * t), this }, rotate: function (t) { var e = this.values.hsl, i = (e[0] + t) % 360; return e[0] = i < 0 ? 360 + i : i, this.setValues("hsl", e), this }, mix: function (t, e) { var i = t, n = void 0 === e ? .5 : e, o = 2 * n - 1, a = this.alpha() - i.alpha(), s = ((o * a == -1 ? o : (o + a) / (1 + o * a)) + 1) / 2, l = 1 - s; return this.rgb(s * this.red() + l * i.red(), s * this.green() + l * i.green(), s * this.blue() + l * i.blue()).alpha(this.alpha() * n + i.alpha() * (1 - n)) }, toJSON: function () { return this.rgb() }, clone: function () { var t, e, i = new a, n = this.values, o = i.values; for (var s in n) n.hasOwnProperty(s) && (t = n[s], "[object Array]" === (e = ({}).toString.call(t)) ? o[s] = t.slice(0) : "[object Number]" === e ? o[s] = t : console.error("unexpected color value:", t)); return i } }, a.prototype.spaces = { rgb: ["red", "green", "blue"], hsl: ["hue", "saturation", "lightness"], hsv: ["hue", "saturation", "value"], hwb: ["hue", "whiteness", "blackness"], cmyk: ["cyan", "magenta", "yellow", "black"] }, a.prototype.maxes = { rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100] }, a.prototype.getValues = function (t) { for (var e = this.values, i = {}, n = 0; n < t.length; n++)i[t.charAt(n)] = e[t][n]; return 1 !== e.alpha && (i.a = e.alpha), i }, a.prototype.setValues = function (t, e) { var i, o, a = this.values, s = this.spaces, l = this.maxes, u = 1; if ("alpha" === t) u = e; else if (e.length) a[t] = e.slice(0, t.length), u = e[t.length]; else if (void 0 !== e[t.charAt(0)]) { for (o = 0; o < t.length; o++)a[t][o] = e[t.charAt(o)]; u = e.a } else if (void 0 !== e[s[t][0]]) { var c = s[t]; for (o = 0; o < t.length; o++)a[t][o] = e[c[o]]; u = e.alpha } if (a.alpha = Math.max(0, Math.min(1, void 0 === u ? a.alpha : u)), "alpha" === t) return !1; for (o = 0; o < t.length; o++)i = Math.max(0, Math.min(l[t][o], a[t][o])), a[t][o] = Math.round(i); for (var d in s) d !== t && (a[d] = n[t][d](a[t])); return !0 }, a.prototype.setSpace = function (t, e) { var i = e[0]; return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i), this) }, a.prototype.setChannel = function (t, e, i) { var n = this.values[t]; return void 0 === i ? n[e] : (i === n[e] || (n[e] = i, this.setValues(t, n)), this) }, "undefined" != typeof window && (window.Color = a), e.exports = a }, { 2: 2, 5: 5 },], 4: [function (t, e, i) { function n(t) { var e, i, n, o = t[0] / 255, a = t[1] / 255, s = t[2] / 255, l = Math.min(o, a, s), u = Math.max(o, a, s), c = u - l; return u == l ? e = 0 : o == u ? e = (a - s) / c : a == u ? e = 2 + (s - o) / c : s == u && (e = 4 + (o - a) / c), (e = Math.min(60 * e, 360)) < 0 && (e += 360), n = (l + u) / 2, [e, 100 * (i = u == l ? 0 : n <= .5 ? c / (u + l) : c / (2 - u - l)), 100 * n] } function o(t) { var e, i, n, o = t[0], a = t[1], s = t[2], l = Math.min(o, a, s), u = Math.max(o, a, s), c = u - l; return i = 0 == u ? 0 : c / u * 1e3 / 10, u == l ? e = 0 : o == u ? e = (a - s) / c : a == u ? e = 2 + (s - o) / c : s == u && (e = 4 + (o - a) / c), (e = Math.min(60 * e, 360)) < 0 && (e += 360), [e, i, n = u / 255 * 1e3 / 10] } function a(t) { var e = t[0], i = t[1], o = t[2], a = n(t)[0], o = 1 - 1 / 255 * Math.max(e, Math.max(i, o)); return [a, 100 * (1 / 255 * Math.min(e, Math.min(i, o))), 100 * o] } function s(t) { var e, i, n, o, a = t[0] / 255, s = t[1] / 255, l = t[2] / 255; return o = Math.min(1 - a, 1 - s, 1 - l), e = (1 - a - o) / (1 - o) || 0, [100 * e, 100 * (i = (1 - s - o) / (1 - o) || 0), 100 * (n = (1 - l - o) / (1 - o) || 0), 100 * o] } function l(t) { return w[JSON.stringify(t)] } function u(t) { var e = t[0] / 255, i = t[1] / 255, n = t[2] / 255; e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92; var o, a = .4124 * e + .3576 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .1805 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92); return [100 * a, 100 * (.2126 * e + .7152 * i + .0722 * n), 100 * (.0193 * e + .1192 * i + .9505 * n)] } function c(t) { var e, i, n, o = u(t), a = o[0], s = o[1], l = o[2]; return a /= 95.047, s /= 100, l /= 108.883, a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116, s = s > .008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, l = l > .008856 ? Math.pow(l, 1 / 3) : 7.787 * l + 16 / 116, e = 116 * s - 16, [e, i = 500 * (a - s), n = 200 * (s - l)] } function d(t) { var e, i, n, o, a, s = t[0] / 360, l = t[1] / 100, u = t[2] / 100; if (0 == l) return [a = 255 * u, a, a]; i = u < .5 ? u * (1 + l) : u + l - u * l, e = 2 * u - i, o = [0, 0, 0]; for (var c = 0; c < 3; c++)(n = s + -(1 / 3 * (c - 1))) < 0 && n++, n > 1 && n--, a = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e, o[c] = 255 * a; return o } function h(t) { var e = t[0] / 60, i = t[1] / 100, n = t[2] / 100, o = e - Math.floor(e), a = 255 * n * (1 - i), s = 255 * n * (1 - i * o), l = 255 * n * (1 - i * (1 - o)), n = 255 * n; switch (Math.floor(e) % 6) { case 0: return [n, l, a]; case 1: return [s, n, a]; case 2: return [a, n, l]; case 3: return [a, s, n]; case 4: return [l, a, n]; case 5: return [n, a, s] } } function f(t) { var e, i, n, o, a = t[0] / 360, s = t[1] / 100, l = t[2] / 100, u = s + l; switch (u > 1 && (s /= u, l /= u), e = Math.floor(6 * a), i = 1 - l, n = 6 * a - e, 0 != (1 & e) && (n = 1 - n), o = s + n * (i - s), e) { default: case 6: case 0: r = i, g = o, b = s; break; case 1: r = o, g = i, b = s; break; case 2: r = s, g = i, b = o; break; case 3: r = s, g = o, b = i; break; case 4: r = o, g = s, b = i; break; case 5: r = i, g = s, b = o }return [255 * r, 255 * g, 255 * b] } function p(t) { var e, i, n, o = t[0] / 100, a = t[1] / 100, s = t[2] / 100, l = t[3] / 100; return e = 1 - Math.min(1, o * (1 - l) + l), [255 * e, 255 * (i = 1 - Math.min(1, a * (1 - l) + l)), 255 * (n = 1 - Math.min(1, s * (1 - l) + l))] } function $(t) { var e, i, n, o = t[0] / 100, a = t[1] / 100, s = t[2] / 100; return e = 3.2406 * o + -1.5372 * a + -.4986 * s, i = -.9689 * o + 1.8758 * a + .0415 * s, n = .0557 * o + -.204 * a + 1.057 * s, e = e > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e *= 12.92, i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i *= 12.92, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : n *= 12.92, e = Math.min(Math.max(0, e), 1), [255 * e, 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (n = Math.min(Math.max(0, n), 1))] } function m(t) { var e, i, n, o = t[0], a = t[1], s = t[2]; return o /= 95.047, a /= 100, s /= 108.883, o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116, a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116, s = s > .008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, e = 116 * a - 16, [e, i = 500 * (o - a), n = 200 * (a - s)] } function v(t) { var e, i, n, o, a = t[0], s = t[1], l = t[2]; return o = a <= 8 ? 7.787 * ((i = 100 * a / 903.3) / 100) + 16 / 116 : Math.pow((i = 100 * Math.pow((a + 16) / 116, 3)) / 100, 1 / 3), [e = e / 95.047 <= .008856 ? e = 95.047 * (s / 500 + o - 16 / 116) / 7.787 : 95.047 * Math.pow(s / 500 + o, 3), i, n = n / 108.883 <= .008859 ? n = 108.883 * (o - l / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(o - l / 200, 3)] } function _(t) { var e, i, n, o = t[0], a = t[1], s = t[2]; return (i = 360 * (e = Math.atan2(s, a)) / 2 / Math.PI) < 0 && (i += 360), [o, n = Math.sqrt(a * a + s * s), i] } function x(t) { return $(v(t)) } function y(t) { var e, i, n, o = t[0], a = t[1]; return [o, e = a * Math.cos(n = t[2] / 360 * 2 * Math.PI), i = a * Math.sin(n)] } function k(t) { return S[t] } e.exports = { rgb2hsl: n, rgb2hsv: o, rgb2hwb: a, rgb2cmyk: s, rgb2keyword: l, rgb2xyz: u, rgb2lab: c, rgb2lch: function t(e) { return _(c(e)) }, hsl2rgb: d, hsl2hsv: function t(e) { var i, n, o = e[0], a = e[1] / 100, s = e[2] / 100; return 0 === s ? [0, 0, 0] : (s *= 2, a *= s <= 1 ? s : 2 - s, n = (s + a) / 2, [o, 100 * (i = 2 * a / (s + a)), 100 * n]) }, hsl2hwb: function t(e) { return a(d(e)) }, hsl2cmyk: function t(e) { return s(d(e)) }, hsl2keyword: function t(e) { return l(d(e)) }, hsv2rgb: h, hsv2hsl: function t(e) { var i, n, o = e[0], a = e[1] / 100, s = e[2] / 100; return n = (2 - a) * s, i = a * s, i /= n <= 1 ? n : 2 - n, [o, 100 * (i = i || 0), 100 * (n /= 2)] }, hsv2hwb: function t(e) { return a(h(e)) }, hsv2cmyk: function t(e) { return s(h(e)) }, hsv2keyword: function t(e) { return l(h(e)) }, hwb2rgb: f, hwb2hsl: function t(e) { return n(f(e)) }, hwb2hsv: function t(e) { return o(f(e)) }, hwb2cmyk: function t(e) { return s(f(e)) }, hwb2keyword: function t(e) { return l(f(e)) }, cmyk2rgb: p, cmyk2hsl: function t(e) { return n(p(e)) }, cmyk2hsv: function t(e) { return o(p(e)) }, cmyk2hwb: function t(e) { return a(p(e)) }, cmyk2keyword: function t(e) { return l(p(e)) }, keyword2rgb: k, keyword2hsl: function t(e) { var i; return n(S[i = e]) }, keyword2hsv: function t(e) { var i; return o(S[i = e]) }, keyword2hwb: function t(e) { var i; return a(S[i = e]) }, keyword2cmyk: function t(e) { var i; return s(S[i = e]) }, keyword2lab: function t(e) { var i; return c(S[i = e]) }, keyword2xyz: function t(e) { var i; return u(S[i = e]) }, xyz2rgb: $, xyz2lab: m, xyz2lch: function t(e) { return _(m(e)) }, lab2xyz: v, lab2rgb: x, lab2lch: _, lch2lab: y, lch2xyz: function t(e) { return v(y(e)) }, lch2rgb: function t(e) { return x(y(e)) } }; var S = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, w = {}; for (var C in S) w[JSON.stringify(S[C])] = C }, {},], 5: [function (t, e, i) { var n = t(4), o = function () { return new c }; for (var a in n) { o[a + "Raw"] = function (t) { return function (e) { return "number" == typeof e && (e = Array.prototype.slice.call(arguments)), n[t](e) } }(a); var s = /(\w+)2(\w+)/.exec(a), l = s[1], u = s[2]; o[l] = o[l] || {}, o[l][u] = o[a] = function (t) { return function (e) { "number" == typeof e && (e = Array.prototype.slice.call(arguments)); var i = n[t](e); if ("string" == typeof i || void 0 === i) return i; for (var o = 0; o < i.length; o++)i[o] = Math.round(i[o]); return i } }(a) } var c = function () { this.convs = {} }; c.prototype.routeSpace = function (t, e) { var i = e[0]; return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i)) }, c.prototype.setValues = function (t, e) { return this.space = t, this.convs = {}, this.convs[t] = e, this }, c.prototype.getValues = function (t) { var e = this.convs[t]; if (!e) { var i = this.space, n = this.convs[i]; e = o[i][t](n), this.convs[t] = e } return e }, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (t) { c.prototype[t] = function (e) { return this.routeSpace(t, arguments) } }), e.exports = o }, { 4: 4 },], 6: [function (t, e, i) { e.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] } }, {},], 7: [function (t, e, i) { var n = t(28)(); t(26)(n), t(42)(n), t(22)(n), t(31)(n), t(25)(n), t(21)(n), t(23)(n), t(24)(n), t(29)(n), t(33)(n), t(34)(n), t(32)(n), t(35)(n), t(30)(n), t(27)(n), t(36)(n), t(37)(n), t(38)(n), t(39)(n), t(40)(n), t(45)(n), t(43)(n), t(44)(n), t(46)(n), t(47)(n), t(48)(n), t(15)(n), t(16)(n), t(17)(n), t(18)(n), t(19)(n), t(20)(n), t(8)(n), t(9)(n), t(10)(n), t(11)(n), t(12)(n), t(13)(n), t(14)(n), window.Chart = e.exports = n }, { 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 8: 8, 9: 9 },], 8: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Bar = function (e, i) { return i.type = "bar", new t(e, i) } } }, {},], 9: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Bubble = function (e, i) { return i.type = "bubble", new t(e, i) } } }, {},], 10: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Doughnut = function (e, i) { return i.type = "doughnut", new t(e, i) } } }, {},], 11: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Line = function (e, i) { return i.type = "line", new t(e, i) } } }, {},], 12: [function (t, e, i) { "use strict"; e.exports = function (t) { t.PolarArea = function (e, i) { return i.type = "polarArea", new t(e, i) } } }, {},], 13: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Radar = function (e, i) { return i.type = "radar", new t(e, i) } } }, {},], 14: [function (t, e, i) { "use strict"; e.exports = function (t) { t.defaults.scatter = { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-1" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-1" }] }, tooltips: { callbacks: { title: function () { return "" }, label: function (t) { return "(" + t.xLabel + ", " + t.yLabel + ")" } } } }, t.controllers.scatter = t.controllers.line, t.Scatter = function (e, i) { return i.type = "scatter", new t(e, i) } } }, {},], 15: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.bar = { hover: { mode: "label" }, scales: { xAxes: [{ type: "category", categoryPercentage: .8, barPercentage: .9, gridLines: { offsetGridLines: !0 } },], yAxes: [{ type: "linear" }] } }, t.controllers.bar = t.DatasetController.extend({ dataElementType: t.elements.Rectangle, initialize: function (e, i) { t.DatasetController.prototype.initialize.call(this, e, i); var n = this.getMeta(), o = this.getDataset(); n.stack = o.stack, n.bar = !0 }, getStackCount: function () { var t = this, i = t.getMeta(), n = t.getScaleForId(i.yAxisID), o = []; return e.each(t.chart.data.datasets, function (e, i) { var a = t.chart.getDatasetMeta(i); a.bar && t.chart.isDatasetVisible(i) && (!1 === n.options.stacked || !0 === n.options.stacked && -1 === o.indexOf(a.stack) || void 0 === n.options.stacked && (void 0 === a.stack || -1 === o.indexOf(a.stack))) && o.push(a.stack) }, t), o.length }, update: function (t) { var i = this; e.each(i.getMeta().data, function (e, n) { i.updateElement(e, n, t) }, i) }, updateElement: function (t, i, n) { var o = this.getMeta(), a = this.getScaleForId(o.xAxisID), s = this.getScaleForId(o.yAxisID), l = s.getBasePixel(), u = this.chart.options.elements.rectangle, c = t.custom || {}, d = this.getDataset(); t._xScale = a, t._yScale = s, t._datasetIndex = this.index, t._index = i; var h = this.getRuler(i); t._model = { x: this.calculateBarX(i, this.index, h), y: n ? l : this.calculateBarY(i, this.index), label: this.chart.data.labels[i], datasetLabel: d.label, horizontal: !1, base: n ? l : this.calculateBarBase(this.index, i), width: this.calculateBarWidth(h), backgroundColor: c.backgroundColor ? c.backgroundColor : e.getValueAtIndexOrDefault(d.backgroundColor, i, u.backgroundColor), borderSkipped: c.borderSkipped ? c.borderSkipped : u.borderSkipped, borderColor: c.borderColor ? c.borderColor : e.getValueAtIndexOrDefault(d.borderColor, i, u.borderColor), borderWidth: c.borderWidth ? c.borderWidth : e.getValueAtIndexOrDefault(d.borderWidth, i, u.borderWidth) }, t.pivot() }, calculateBarBase: function (t, e) { var i = this.getMeta(), n = this.getScaleForId(i.yAxisID), o = n.getBaseValue(), a = o; if (!0 === n.options.stacked || void 0 === n.options.stacked && void 0 !== i.stack) { for (var s = this.chart, l = s.data.datasets, u = Number(l[t].data[e]), c = 0; c < t; c++) { var d = l[c], h = s.getDatasetMeta(c); if (h.bar && h.yAxisID === n.id && s.isDatasetVisible(c) && i.stack === h.stack) { var f = Number(d.data[e]); o += u < 0 ? Math.min(f, a) : Math.max(f, a) } } return n.getPixelForValue(o) } return n.getBasePixel() }, getRuler: function () { var t = this.getMeta(), e = this.getScaleForId(t.xAxisID), i = this.getStackCount(), n = e.width / e.ticks.length, o = n * e.options.categoryPercentage, a = (n - n * e.options.categoryPercentage) / 2, s = o / i, l = s * e.options.barPercentage, u = s - s * e.options.barPercentage; return { stackCount: i, tickWidth: n, categoryWidth: o, categorySpacing: a, fullBarWidth: s, barWidth: l, barSpacing: u } }, calculateBarWidth: function (t) { var e = this.getMeta(), i = this.getScaleForId(e.xAxisID); return i.options.barThickness ? i.options.barThickness : t.barWidth }, getStackIndex: function (t) { var e, i, n = this.chart.getDatasetMeta(t), o = this.getScaleForId(n.yAxisID), a = [n.stack]; for (i = 0; i < t; ++i)(e = this.chart.getDatasetMeta(i)).bar && this.chart.isDatasetVisible(i) && (!1 === o.options.stacked || !0 === o.options.stacked && -1 === a.indexOf(e.stack) || void 0 === o.options.stacked && (void 0 === e.stack || -1 === a.indexOf(e.stack))) && a.push(e.stack); return a.length - 1 }, calculateBarX: function (t, e, i) { var n = this.getMeta(), o = this.getScaleForId(n.xAxisID), a = this.getStackIndex(e), s = o.getPixelForValue(null, t, e, this.chart.isCombo); return (s -= this.chart.isCombo ? i.tickWidth / 2 : 0) + i.barWidth / 2 + i.categorySpacing + i.barWidth * a + i.barSpacing / 2 + i.barSpacing * a }, calculateBarY: function (t, e) { var i = this.getMeta(), n = this.getScaleForId(i.yAxisID), o = Number(this.getDataset().data[t]); if (n.options.stacked || void 0 === n.options.stacked && void 0 !== i.stack) { for (var a = n.getBaseValue(), s = a, l = a, u = 0; u < e; u++) { var c = this.chart.data.datasets[u], d = this.chart.getDatasetMeta(u); if (d.bar && d.yAxisID === n.id && this.chart.isDatasetVisible(u) && i.stack === d.stack) { var h = Number(c.data[t]); h < 0 ? l += h || 0 : s += h || 0 } } return o < 0 ? n.getPixelForValue(l + o) : n.getPixelForValue(s + o) } return n.getPixelForValue(o) }, draw: function (e) { var i, n, o = e || 1, a = this.getMeta().data, s = this.getDataset(); for (t.canvasHelpers.clipArea(this.chart.chart.ctx, this.chart.chartArea), i = 0, n = a.length; i < n; ++i) { var l = s.data[i]; null == l || isNaN(l) || a[i].transition(o).draw() } t.canvasHelpers.unclipArea(this.chart.chart.ctx) }, setHoverStyle: function (t) { var i = this.chart.data.datasets[t._datasetIndex], n = t._index, o = t.custom || {}, a = t._model; a.backgroundColor = o.hoverBackgroundColor ? o.hoverBackgroundColor : e.getValueAtIndexOrDefault(i.hoverBackgroundColor, n, e.getHoverColor(a.backgroundColor)), a.borderColor = o.hoverBorderColor ? o.hoverBorderColor : e.getValueAtIndexOrDefault(i.hoverBorderColor, n, e.getHoverColor(a.borderColor)), a.borderWidth = o.hoverBorderWidth ? o.hoverBorderWidth : e.getValueAtIndexOrDefault(i.hoverBorderWidth, n, a.borderWidth) }, removeHoverStyle: function (t) { var i = this.chart.data.datasets[t._datasetIndex], n = t._index, o = t.custom || {}, a = t._model, s = this.chart.options.elements.rectangle; a.backgroundColor = o.backgroundColor ? o.backgroundColor : e.getValueAtIndexOrDefault(i.backgroundColor, n, s.backgroundColor), a.borderColor = o.borderColor ? o.borderColor : e.getValueAtIndexOrDefault(i.borderColor, n, s.borderColor), a.borderWidth = o.borderWidth ? o.borderWidth : e.getValueAtIndexOrDefault(i.borderWidth, n, s.borderWidth) } }), t.defaults.horizontalBar = { hover: { mode: "label" }, scales: { xAxes: [{ type: "linear", position: "bottom" }], yAxes: [{ position: "left", type: "category", categoryPercentage: .8, barPercentage: .9, gridLines: { offsetGridLines: !0 } },] }, elements: { rectangle: { borderSkipped: "left" } }, tooltips: { callbacks: { title: function (t, e) { var i = ""; return t.length > 0 && (t[0].yLabel ? i = t[0].yLabel : e.labels.length > 0 && t[0].index < e.labels.length && (i = e.labels[t[0].index])), i }, label: function (t, e) { return (e.datasets[t.datasetIndex].label || "") + ": " + t.xLabel } } } }, t.controllers.horizontalBar = t.controllers.bar.extend({ getStackCount: function () { var t = this, i = t.getMeta(), n = t.getScaleForId(i.xAxisID), o = []; return e.each(t.chart.data.datasets, function (e, i) { var a = t.chart.getDatasetMeta(i); a.bar && t.chart.isDatasetVisible(i) && (!1 === n.options.stacked || !0 === n.options.stacked && -1 === o.indexOf(a.stack) || void 0 === n.options.stacked && (void 0 === a.stack || -1 === o.indexOf(a.stack))) && o.push(a.stack) }, t), o.length }, updateElement: function (t, i, n) { var o = this.getMeta(), a = this.getScaleForId(o.xAxisID), s = this.getScaleForId(o.yAxisID), l = a.getBasePixel(), u = t.custom || {}, c = this.getDataset(), d = this.chart.options.elements.rectangle; t._xScale = a, t._yScale = s, t._datasetIndex = this.index, t._index = i; var h = this.getRuler(i); t._model = { x: n ? l : this.calculateBarX(i, this.index), y: this.calculateBarY(i, this.index, h), label: this.chart.data.labels[i], datasetLabel: c.label, horizontal: !0, base: n ? l : this.calculateBarBase(this.index, i), height: this.calculateBarHeight(h), backgroundColor: u.backgroundColor ? u.backgroundColor : e.getValueAtIndexOrDefault(c.backgroundColor, i, d.backgroundColor), borderSkipped: u.borderSkipped ? u.borderSkipped : d.borderSkipped, borderColor: u.borderColor ? u.borderColor : e.getValueAtIndexOrDefault(c.borderColor, i, d.borderColor), borderWidth: u.borderWidth ? u.borderWidth : e.getValueAtIndexOrDefault(c.borderWidth, i, d.borderWidth) }, t.pivot() }, calculateBarBase: function (t, e) { var i = this.getMeta(), n = this.getScaleForId(i.xAxisID), o = n.getBaseValue(), a = o; if (n.options.stacked || void 0 === n.options.stacked && void 0 !== i.stack) { for (var s = this.chart, l = s.data.datasets, u = Number(l[t].data[e]), c = 0; c < t; c++) { var d = l[c], h = s.getDatasetMeta(c); if (h.bar && h.xAxisID === n.id && s.isDatasetVisible(c) && i.stack === h.stack) { var f = Number(d.data[e]); o += u < 0 ? Math.min(f, a) : Math.max(f, a) } } return n.getPixelForValue(o) } return n.getBasePixel() }, getRuler: function () { var t = this.getMeta(), e = this.getScaleForId(t.yAxisID), i = this.getStackCount(), n = e.height / e.ticks.length, o = n * e.options.categoryPercentage, a = (n - n * e.options.categoryPercentage) / 2, s = o / i, l = s * e.options.barPercentage, u = s - s * e.options.barPercentage; return { stackCount: i, tickHeight: n, categoryHeight: o, categorySpacing: a, fullBarHeight: s, barHeight: l, barSpacing: u } }, calculateBarHeight: function (t) { var e = this.getMeta(), i = this.getScaleForId(e.yAxisID); return i.options.barThickness ? i.options.barThickness : t.barHeight }, getStackIndex: function (t) { var e, i, n = this.chart.getDatasetMeta(t), o = this.getScaleForId(n.xAxisID), a = [n.stack]; for (i = 0; i < t; ++i)(e = this.chart.getDatasetMeta(i)).bar && this.chart.isDatasetVisible(i) && (!1 === o.options.stacked || !0 === o.options.stacked && -1 === a.indexOf(e.stack) || void 0 === o.options.stacked && (void 0 === e.stack || -1 === a.indexOf(e.stack))) && a.push(e.stack); return a.length - 1 }, calculateBarX: function (t, e) { var i = this.getMeta(), n = this.getScaleForId(i.xAxisID), o = Number(this.getDataset().data[t]); if (n.options.stacked || void 0 === n.options.stacked && void 0 !== i.stack) { for (var a = n.getBaseValue(), s = a, l = a, u = 0; u < e; u++) { var c = this.chart.data.datasets[u], d = this.chart.getDatasetMeta(u); if (d.bar && d.xAxisID === n.id && this.chart.isDatasetVisible(u) && i.stack === d.stack) { var h = Number(c.data[t]); h < 0 ? l += h || 0 : s += h || 0 } } return o < 0 ? n.getPixelForValue(l + o) : n.getPixelForValue(s + o) } return n.getPixelForValue(o) }, calculateBarY: function (t, e, i) { var n = this.getMeta(), o = this.getScaleForId(n.yAxisID), a = this.getStackIndex(e), s = o.getPixelForValue(null, t, e, this.chart.isCombo); return (s -= this.chart.isCombo ? i.tickHeight / 2 : 0) + i.barHeight / 2 + i.categorySpacing + i.barHeight * a + i.barSpacing / 2 + i.barSpacing * a } }) } }, {},], 16: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.bubble = { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] }, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { var i = e.datasets[t.datasetIndex].label || "", n = e.datasets[t.datasetIndex].data[t.index]; return i + ": (" + t.xLabel + ", " + t.yLabel + ", " + n.r + ")" } } } }, t.controllers.bubble = t.DatasetController.extend({ dataElementType: t.elements.Point, update: function (t) { var i = this, n = i.getMeta().data; e.each(n, function (e, n) { i.updateElement(e, n, t) }) }, updateElement: function (i, n, o) { var a = this.getMeta(), s = this.getScaleForId(a.xAxisID), l = this.getScaleForId(a.yAxisID), u = i.custom || {}, c = this.getDataset(), d = c.data[n], h = this.chart.options.elements.point, f = this.index; e.extend(i, { _xScale: s, _yScale: l, _datasetIndex: f, _index: n, _model: { x: o ? s.getPixelForDecimal(.5) : s.getPixelForValue("object" == typeof d ? d : NaN, n, f, this.chart.isCombo), y: o ? l.getBasePixel() : l.getPixelForValue(d, n, f), radius: o ? 0 : u.radius ? u.radius : this.getRadius(d), hitRadius: u.hitRadius ? u.hitRadius : e.getValueAtIndexOrDefault(c.hitRadius, n, h.hitRadius) } }), t.DatasetController.prototype.removeHoverStyle.call(this, i, h); var p = i._model; p.skip = u.skip ? u.skip : isNaN(p.x) || isNaN(p.y), i.pivot() }, getRadius: function (t) { return t.r || this.chart.options.elements.point.radius }, setHoverStyle: function (i) { t.DatasetController.prototype.setHoverStyle.call(this, i); var n = this.chart.data.datasets[i._datasetIndex], o = i._index, a = i.custom || {}; i._model.radius = a.hoverRadius ? a.hoverRadius : e.getValueAtIndexOrDefault(n.hoverRadius, o, this.chart.options.elements.point.hoverRadius) + this.getRadius(n.data[o]) }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.point); var i = this.chart.data.datasets[e._datasetIndex].data[e._index], n = e.custom || {}; e._model.radius = n.radius ? n.radius : this.getRadius(i) } }) } }, {},], 17: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers, i = t.defaults; i.doughnut = { animation: { animateRotate: !0, animateScale: !1 }, aspectRatio: 1, hover: { mode: "single" }, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var i = t.data, n = i.datasets, o = i.labels; if (n.length) for (var a = 0; a < n[0].data.length; ++a)e.push('<li><span style="background-color:' + n[0].backgroundColor[a] + '"></span>'), o[a] && e.push(o[a]), e.push("</li>"); return e.push("</ul>"), e.join("") }, legend: { labels: { generateLabels: function (t) { var i = t.data; return i.labels.length && i.datasets.length ? i.labels.map(function (n, o) { var a = t.getDatasetMeta(0), s = i.datasets[0], l = a.data[o], u = l && l.custom || {}, c = e.getValueAtIndexOrDefault, d = t.options.elements.arc, h = u.backgroundColor ? u.backgroundColor : c(s.backgroundColor, o, d.backgroundColor), f = u.borderColor ? u.borderColor : c(s.borderColor, o, d.borderColor), p = u.borderWidth ? u.borderWidth : c(s.borderWidth, o, d.borderWidth); return { text: n, fillStyle: h, strokeStyle: f, lineWidth: p, hidden: isNaN(s.data[o]) || a.data[o].hidden, index: o } }) : [] } }, onClick: function (t, e) { var i, n, o, a = e.index, s = this.chart; for (i = 0, n = (s.data.datasets || []).length; i < n; ++i)(o = s.getDatasetMeta(i)).data[a] && (o.data[a].hidden = !o.data[a].hidden); s.update() } }, cutoutPercentage: 50, rotation: -.5 * Math.PI, circumference: 2 * Math.PI, tooltips: { callbacks: { title: function () { return "" }, label: function (t, i) { var n = i.labels[t.index], o = ": " + i.datasets[t.datasetIndex].data[t.index]; return e.isArray(n) ? (n = n.slice(), n[0] += o) : n += o, n } } } }, i.pie = e.clone(i.doughnut), e.extend(i.pie, { cutoutPercentage: 0 }), t.controllers.doughnut = t.controllers.pie = t.DatasetController.extend({ dataElementType: t.elements.Arc, linkScales: e.noop, getRingIndex: function (t) { for (var e = 0, i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && ++e; return e }, update: function (t) { var i = this, n = i.chart, o = n.chartArea, a = n.options, s = a.elements.arc, l = o.right - o.left - s.borderWidth, u = o.bottom - o.top - s.borderWidth, c = Math.min(l, u), d = { x: 0, y: 0 }, h = i.getMeta(), f = a.cutoutPercentage, p = a.circumference; if (p < 2 * Math.PI) { var $ = a.rotation % (2 * Math.PI); $ += 2 * Math.PI * ($ >= Math.PI ? -1 : $ < -Math.PI ? 1 : 0); var m = $ + p, v = { x: Math.cos($), y: Math.sin($) }, _ = { x: Math.cos(m), y: Math.sin(m) }, x = $ <= 0 && 0 <= m || $ <= 2 * Math.PI && 2 * Math.PI <= m, y = $ <= .5 * Math.PI && .5 * Math.PI <= m || $ <= 2.5 * Math.PI && 2.5 * Math.PI <= m, k = $ <= -Math.PI && -Math.PI <= m || $ <= Math.PI && Math.PI <= m, S = $ <= -(.5 * Math.PI) && -(.5 * Math.PI) <= m || $ <= 1.5 * Math.PI && 1.5 * Math.PI <= m, w = f / 100, C = { x: k ? -1 : Math.min(v.x * (v.x < 0 ? 1 : w), _.x * (_.x < 0 ? 1 : w)), y: S ? -1 : Math.min(v.y * (v.y < 0 ? 1 : w), _.y * (_.y < 0 ? 1 : w)) }, D = { x: x ? 1 : Math.max(v.x * (v.x > 0 ? 1 : w), _.x * (_.x > 0 ? 1 : w)), y: y ? 1 : Math.max(v.y * (v.y > 0 ? 1 : w), _.y * (_.y > 0 ? 1 : w)) }, I = { width: .5 * (D.x - C.x), height: .5 * (D.y - C.y) }; c = Math.min(l / I.width, u / I.height), d = { x: -((D.x + C.x) * .5), y: -((D.y + C.y) * .5) } } n.borderWidth = i.getMaxBorderWidth(h.data), n.outerRadius = Math.max((c - n.borderWidth) / 2, 0), n.innerRadius = Math.max(f ? n.outerRadius / 100 * f : 0, 0), n.radiusLength = (n.outerRadius - n.innerRadius) / n.getVisibleDatasetCount(), n.offsetX = d.x * n.outerRadius, n.offsetY = d.y * n.outerRadius, h.total = i.calculateTotal(), i.outerRadius = n.outerRadius - n.radiusLength * i.getRingIndex(i.index), i.innerRadius = Math.max(i.outerRadius - n.radiusLength, 0), e.each(h.data, function (e, n) { i.updateElement(e, n, t) }) }, updateElement: function (t, i, n) { var o = this.chart, a = o.chartArea, s = o.options, l = s.animation, u = (a.left + a.right) / 2, c = (a.top + a.bottom) / 2, d = s.rotation, h = s.rotation, f = this.getDataset(), p = n && l.animateRotate ? 0 : t.hidden ? 0 : this.calculateCircumference(f.data[i]) * (s.circumference / (2 * Math.PI)), $ = n && l.animateScale ? 0 : this.innerRadius, m = n && l.animateScale ? 0 : this.outerRadius, v = e.getValueAtIndexOrDefault; e.extend(t, { _datasetIndex: this.index, _index: i, _model: { x: u + o.offsetX, y: c + o.offsetY, startAngle: d, endAngle: h, circumference: p, outerRadius: m, innerRadius: $, label: v(f.label, i, o.data.labels[i]) } }); var _ = t._model; this.removeHoverStyle(t), n && l.animateRotate || (0 === i ? _.startAngle = s.rotation : _.startAngle = this.getMeta().data[i - 1]._model.endAngle, _.endAngle = _.startAngle + _.circumference), t.pivot() }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc) }, calculateTotal: function () { var t, i = this.getDataset(), n = this.getMeta(), o = 0; return e.each(n.data, function (e, n) { isNaN(t = i.data[n]) || e.hidden || (o += Math.abs(t)) }), o }, calculateCircumference: function (t) { var e = this.getMeta().total; return e > 0 && !isNaN(t) ? 2 * Math.PI * (t / e) : 0 }, getMaxBorderWidth: function (t) { for (var e, i, n = 0, o = this.index, a = t.length, s = 0; s < a; s++)e = t[s]._model ? t[s]._model.borderWidth : 0, n = (i = t[s]._chart ? t[s]._chart.config.data.datasets[o].hoverBorderWidth : 0) > (n = e > n ? e : n) ? i : n; return n } }) } }, {},], 18: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t, e) { return i.getValueOrDefault(t.showLine, e.showLines) } var i = t.helpers; t.defaults.line = { showLines: !0, spanGaps: !1, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] } }, t.controllers.line = t.DatasetController.extend({ datasetElementType: t.elements.Line, dataElementType: t.elements.Point, update: function (t) { var n, o, a, s = this.getMeta(), l = s.dataset, u = s.data || [], c = this.chart.options, d = c.elements.line, h = this.getScaleForId(s.yAxisID), f = this.getDataset(), p = e(f, c); for (p && (a = l.custom || {}, void 0 !== f.tension && void 0 === f.lineTension && (f.lineTension = f.tension), l._scale = h, l._datasetIndex = this.index, l._children = u, l._model = { spanGaps: f.spanGaps ? f.spanGaps : c.spanGaps, tension: a.tension ? a.tension : i.getValueOrDefault(f.lineTension, d.tension), backgroundColor: a.backgroundColor ? a.backgroundColor : f.backgroundColor || d.backgroundColor, borderWidth: a.borderWidth ? a.borderWidth : f.borderWidth || d.borderWidth, borderColor: a.borderColor ? a.borderColor : f.borderColor || d.borderColor, borderCapStyle: a.borderCapStyle ? a.borderCapStyle : f.borderCapStyle || d.borderCapStyle, borderDash: a.borderDash ? a.borderDash : f.borderDash || d.borderDash, borderDashOffset: a.borderDashOffset ? a.borderDashOffset : f.borderDashOffset || d.borderDashOffset, borderJoinStyle: a.borderJoinStyle ? a.borderJoinStyle : f.borderJoinStyle || d.borderJoinStyle, fill: a.fill ? a.fill : void 0 !== f.fill ? f.fill : d.fill, steppedLine: a.steppedLine ? a.steppedLine : i.getValueOrDefault(f.steppedLine, d.stepped), cubicInterpolationMode: a.cubicInterpolationMode ? a.cubicInterpolationMode : i.getValueOrDefault(f.cubicInterpolationMode, d.cubicInterpolationMode), scaleTop: h.top, scaleBottom: h.bottom, scaleZero: h.getBasePixel() }, l.pivot()), n = 0, o = u.length; n < o; ++n)this.updateElement(u[n], n, t); for (p && 0 !== l._model.tension && this.updateBezierControlPoints(), n = 0, o = u.length; n < o; ++n)u[n].pivot() }, getPointBackgroundColor: function (t, e) { var n = this.chart.options.elements.point.backgroundColor, o = this.getDataset(), a = t.custom || {}; return a.backgroundColor ? n = a.backgroundColor : o.pointBackgroundColor ? n = i.getValueAtIndexOrDefault(o.pointBackgroundColor, e, n) : o.backgroundColor && (n = o.backgroundColor), n }, getPointBorderColor: function (t, e) { var n = this.chart.options.elements.point.borderColor, o = this.getDataset(), a = t.custom || {}; return a.borderColor ? n = a.borderColor : o.pointBorderColor ? n = i.getValueAtIndexOrDefault(o.pointBorderColor, e, n) : o.borderColor && (n = o.borderColor), n }, getPointBorderWidth: function (t, e) { var n = this.chart.options.elements.point.borderWidth, o = this.getDataset(), a = t.custom || {}; return isNaN(a.borderWidth) ? isNaN(o.pointBorderWidth) ? isNaN(o.borderWidth) || (n = o.borderWidth) : n = i.getValueAtIndexOrDefault(o.pointBorderWidth, e, n) : n = a.borderWidth, n }, updateElement: function (t, e, n) { var o, a, s = this.getMeta(), l = t.custom || {}, u = this.getDataset(), c = this.index, d = u.data[e], h = this.getScaleForId(s.yAxisID), f = this.getScaleForId(s.xAxisID), p = this.chart.options.elements.point, $ = 1 === (this.chart.data.labels || []).length || 1 === u.data.length || this.chart.isCombo; void 0 !== u.radius && void 0 === u.pointRadius && (u.pointRadius = u.radius), void 0 !== u.hitRadius && void 0 === u.pointHitRadius && (u.pointHitRadius = u.hitRadius), o = f.getPixelForValue("object" == typeof d ? d : NaN, e, c, $), a = n ? h.getBasePixel() : this.calculatePointY(d, e, c), t._xScale = f, t._yScale = h, t._datasetIndex = c, t._index = e, t._model = { x: o, y: a, skip: l.skip || isNaN(o) || isNaN(a), radius: l.radius || i.getValueAtIndexOrDefault(u.pointRadius, e, p.radius), pointStyle: l.pointStyle || i.getValueAtIndexOrDefault(u.pointStyle, e, p.pointStyle), backgroundColor: this.getPointBackgroundColor(t, e), borderColor: this.getPointBorderColor(t, e), borderWidth: this.getPointBorderWidth(t, e), tension: s.dataset._model ? s.dataset._model.tension : 0, steppedLine: !!s.dataset._model && s.dataset._model.steppedLine, hitRadius: l.hitRadius || i.getValueAtIndexOrDefault(u.pointHitRadius, e, p.hitRadius) } }, calculatePointY: function (t, e, i) { var n, o, a, s = this.chart, l = this.getMeta(), u = this.getScaleForId(l.yAxisID), c = 0, d = 0; if (u.options.stacked) { for (n = 0; n < i; n++)if (o = s.data.datasets[n], "line" === (a = s.getDatasetMeta(n)).type && a.yAxisID === u.id && s.isDatasetVisible(n)) { var h = Number(u.getRightValue(o.data[e])); h < 0 ? d += h || 0 : c += h || 0 } var f = Number(u.getRightValue(t)); return f < 0 ? u.getPixelForValue(d + f) : u.getPixelForValue(c + f) } return u.getPixelForValue(t) }, updateBezierControlPoints: function () { function t(t, e, i) { return Math.max(Math.min(t, i), e) } var e, n, o, a, s, l = this.getMeta(), u = this.chart.chartArea, c = l.data || []; if (l.dataset._model.spanGaps && (c = c.filter(function (t) { return !t._model.skip })), "monotone" === l.dataset._model.cubicInterpolationMode) i.splineCurveMonotone(c); else for (e = 0, n = c.length; e < n; ++e)a = (o = c[e])._model, s = i.splineCurve(i.previousItem(c, e)._model, a, i.nextItem(c, e)._model, l.dataset._model.tension), a.controlPointPreviousX = s.previous.x, a.controlPointPreviousY = s.previous.y, a.controlPointNextX = s.next.x, a.controlPointNextY = s.next.y; if (this.chart.options.elements.line.capBezierPoints) for (e = 0, n = c.length; e < n; ++e)(a = c[e]._model).controlPointPreviousX = t(a.controlPointPreviousX, u.left, u.right), a.controlPointPreviousY = t(a.controlPointPreviousY, u.top, u.bottom), a.controlPointNextX = t(a.controlPointNextX, u.left, u.right), a.controlPointNextY = t(a.controlPointNextY, u.top, u.bottom) }, draw: function (i) { var n, o, a = this.getMeta(), s = a.data || [], l = i || 1; for (n = 0, o = s.length; n < o; ++n)s[n].transition(l); for (t.canvasHelpers.clipArea(this.chart.chart.ctx, this.chart.chartArea), e(this.getDataset(), this.chart.options) && a.dataset.transition(l).draw(), t.canvasHelpers.unclipArea(this.chart.chart.ctx), n = 0, o = s.length; n < o; ++n)s[n].draw(this.chart.chartArea) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], n = t._index, o = t.custom || {}, a = t._model; a.radius = o.hoverRadius || i.getValueAtIndexOrDefault(e.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), a.backgroundColor = o.hoverBackgroundColor || i.getValueAtIndexOrDefault(e.pointHoverBackgroundColor, n, i.getHoverColor(a.backgroundColor)), a.borderColor = o.hoverBorderColor || i.getValueAtIndexOrDefault(e.pointHoverBorderColor, n, i.getHoverColor(a.borderColor)), a.borderWidth = o.hoverBorderWidth || i.getValueAtIndexOrDefault(e.pointHoverBorderWidth, n, a.borderWidth) }, removeHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], n = t._index, o = t.custom || {}, a = t._model; void 0 !== e.radius && void 0 === e.pointRadius && (e.pointRadius = e.radius), a.radius = o.radius || i.getValueAtIndexOrDefault(e.pointRadius, n, this.chart.options.elements.point.radius), a.backgroundColor = this.getPointBackgroundColor(t, n), a.borderColor = this.getPointBorderColor(t, n), a.borderWidth = this.getPointBorderWidth(t, n) } }) } }, {},], 19: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.polarArea = { scale: { type: "radialLinear", lineArc: !0, ticks: { beginAtZero: !0 } }, animation: { animateRotate: !0, animateScale: !0 }, startAngle: -.5 * Math.PI, aspectRatio: 1, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var i = t.data, n = i.datasets, o = i.labels; if (n.length) for (var a = 0; a < n[0].data.length; ++a)e.push('<li><span style="background-color:' + n[0].backgroundColor[a] + '"></span>'), o[a] && e.push(o[a]), e.push("</li>"); return e.push("</ul>"), e.join("") }, legend: { labels: { generateLabels: function (t) { var i = t.data; return i.labels.length && i.datasets.length ? i.labels.map(function (n, o) { var a = t.getDatasetMeta(0), s = i.datasets[0], l = a.data[o].custom || {}, u = e.getValueAtIndexOrDefault, c = t.options.elements.arc, d = l.backgroundColor ? l.backgroundColor : u(s.backgroundColor, o, c.backgroundColor), h = l.borderColor ? l.borderColor : u(s.borderColor, o, c.borderColor), f = l.borderWidth ? l.borderWidth : u(s.borderWidth, o, c.borderWidth); return { text: n, fillStyle: d, strokeStyle: h, lineWidth: f, hidden: isNaN(s.data[o]) || a.data[o].hidden, index: o } }) : [] } }, onClick: function (t, e) { var i, n, o, a = e.index, s = this.chart; for (i = 0, n = (s.data.datasets || []).length; i < n; ++i)(o = s.getDatasetMeta(i)).data[a].hidden = !o.data[a].hidden; s.update() } }, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { return e.labels[t.index] + ": " + t.yLabel } } } }, t.controllers.polarArea = t.DatasetController.extend({ dataElementType: t.elements.Arc, linkScales: e.noop, update: function (t) { var i = this, n = i.chart, o = n.chartArea, a = i.getMeta(), s = n.options, l = s.elements.arc, u = Math.min(o.right - o.left, o.bottom - o.top); n.outerRadius = Math.max((u - l.borderWidth / 2) / 2, 0), n.innerRadius = Math.max(s.cutoutPercentage ? n.outerRadius / 100 * s.cutoutPercentage : 1, 0), n.radiusLength = (n.outerRadius - n.innerRadius) / n.getVisibleDatasetCount(), i.outerRadius = n.outerRadius - n.radiusLength * i.index, i.innerRadius = i.outerRadius - n.radiusLength, a.count = i.countVisibleElements(), e.each(a.data, function (e, n) { i.updateElement(e, n, t) }) }, updateElement: function (t, i, n) { for (var o = this.chart, a = this.getDataset(), s = o.options, l = s.animation, u = o.scale, c = e.getValueAtIndexOrDefault, d = o.data.labels, h = this.calculateCircumference(a.data[i]), f = u.xCenter, p = u.yCenter, $ = 0, m = this.getMeta(), v = 0; v < i; ++v)isNaN(a.data[v]) || m.data[v].hidden || ++$; var _ = s.startAngle, x = t.hidden ? 0 : u.getDistanceFromCenterForValue(a.data[i]), y = _ + h * $, k = y + (t.hidden ? 0 : h), S = l.animateScale ? 0 : u.getDistanceFromCenterForValue(a.data[i]); e.extend(t, { _datasetIndex: this.index, _index: i, _scale: u, _model: { x: f, y: p, innerRadius: 0, outerRadius: n ? S : x, startAngle: n && l.animateRotate ? _ : y, endAngle: n && l.animateRotate ? _ : k, label: c(d, i, d[i]) } }), this.removeHoverStyle(t), t.pivot() }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc) }, countVisibleElements: function () { var t = this.getDataset(), i = this.getMeta(), n = 0; return e.each(i.data, function (e, i) { isNaN(t.data[i]) || e.hidden || n++ }), n }, calculateCircumference: function (t) { var e = this.getMeta().count; return e > 0 && !isNaN(t) ? 2 * Math.PI / e : 0 } }) } }, {},], 20: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.radar = { aspectRatio: 1, scale: { type: "radialLinear" }, elements: { line: { tension: 0 } } }, t.controllers.radar = t.DatasetController.extend({ datasetElementType: t.elements.Line, dataElementType: t.elements.Point, linkScales: e.noop, update: function (t) { var i = this, n = i.getMeta(), o = n.dataset, a = n.data, s = o.custom || {}, l = i.getDataset(), u = i.chart.options.elements.line, c = i.chart.scale; void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), e.extend(n.dataset, { _datasetIndex: i.index, _children: a, _loop: !0, _model: { tension: s.tension ? s.tension : e.getValueOrDefault(l.lineTension, u.tension), backgroundColor: s.backgroundColor ? s.backgroundColor : l.backgroundColor || u.backgroundColor, borderWidth: s.borderWidth ? s.borderWidth : l.borderWidth || u.borderWidth, borderColor: s.borderColor ? s.borderColor : l.borderColor || u.borderColor, fill: s.fill ? s.fill : void 0 !== l.fill ? l.fill : u.fill, borderCapStyle: s.borderCapStyle ? s.borderCapStyle : l.borderCapStyle || u.borderCapStyle, borderDash: s.borderDash ? s.borderDash : l.borderDash || u.borderDash, borderDashOffset: s.borderDashOffset ? s.borderDashOffset : l.borderDashOffset || u.borderDashOffset, borderJoinStyle: s.borderJoinStyle ? s.borderJoinStyle : l.borderJoinStyle || u.borderJoinStyle, scaleTop: c.top, scaleBottom: c.bottom, scaleZero: c.getBasePosition() } }), n.dataset.pivot(), e.each(a, function (e, n) { i.updateElement(e, n, t) }, i), i.updateBezierControlPoints() }, updateElement: function (t, i, n) { var o = t.custom || {}, a = this.getDataset(), s = this.chart.scale, l = this.chart.options.elements.point, u = s.getPointPositionForValue(i, a.data[i]); e.extend(t, { _datasetIndex: this.index, _index: i, _scale: s, _model: { x: n ? s.xCenter : u.x, y: n ? s.yCenter : u.y, tension: o.tension ? o.tension : e.getValueOrDefault(a.lineTension, this.chart.options.elements.line.tension), radius: o.radius ? o.radius : e.getValueAtIndexOrDefault(a.pointRadius, i, l.radius), backgroundColor: o.backgroundColor ? o.backgroundColor : e.getValueAtIndexOrDefault(a.pointBackgroundColor, i, l.backgroundColor), borderColor: o.borderColor ? o.borderColor : e.getValueAtIndexOrDefault(a.pointBorderColor, i, l.borderColor), borderWidth: o.borderWidth ? o.borderWidth : e.getValueAtIndexOrDefault(a.pointBorderWidth, i, l.borderWidth), pointStyle: o.pointStyle ? o.pointStyle : e.getValueAtIndexOrDefault(a.pointStyle, i, l.pointStyle), hitRadius: o.hitRadius ? o.hitRadius : e.getValueAtIndexOrDefault(a.hitRadius, i, l.hitRadius) } }), t._model.skip = o.skip ? o.skip : isNaN(t._model.x) || isNaN(t._model.y) }, updateBezierControlPoints: function () { var t = this.chart.chartArea, i = this.getMeta(); e.each(i.data, function (n, o) { var a = n._model, s = e.splineCurve(e.previousItem(i.data, o, !0)._model, a, e.nextItem(i.data, o, !0)._model, a.tension); a.controlPointPreviousX = Math.max(Math.min(s.previous.x, t.right), t.left), a.controlPointPreviousY = Math.max(Math.min(s.previous.y, t.bottom), t.top), a.controlPointNextX = Math.max(Math.min(s.next.x, t.right), t.left), a.controlPointNextY = Math.max(Math.min(s.next.y, t.bottom), t.top), n.pivot() }) }, draw: function (t) { var i = this.getMeta(), n = t || 1; e.each(i.data, function (t) { t.transition(n) }), i.dataset.transition(n).draw(), e.each(i.data, function (t) { t.draw() }) }, setHoverStyle: function (t) { var i = this.chart.data.datasets[t._datasetIndex], n = t.custom || {}, o = t._index, a = t._model; a.radius = n.hoverRadius ? n.hoverRadius : e.getValueAtIndexOrDefault(i.pointHoverRadius, o, this.chart.options.elements.point.hoverRadius), a.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : e.getValueAtIndexOrDefault(i.pointHoverBackgroundColor, o, e.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor ? n.hoverBorderColor : e.getValueAtIndexOrDefault(i.pointHoverBorderColor, o, e.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : e.getValueAtIndexOrDefault(i.pointHoverBorderWidth, o, a.borderWidth) }, removeHoverStyle: function (t) { var i = this.chart.data.datasets[t._datasetIndex], n = t.custom || {}, o = t._index, a = t._model, s = this.chart.options.elements.point; a.radius = n.radius ? n.radius : e.getValueAtIndexOrDefault(i.radius, o, s.radius), a.backgroundColor = n.backgroundColor ? n.backgroundColor : e.getValueAtIndexOrDefault(i.pointBackgroundColor, o, s.backgroundColor), a.borderColor = n.borderColor ? n.borderColor : e.getValueAtIndexOrDefault(i.pointBorderColor, o, s.borderColor), a.borderWidth = n.borderWidth ? n.borderWidth : e.getValueAtIndexOrDefault(i.pointBorderWidth, o, s.borderWidth) } }) } }, {},], 21: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.global.animation = { duration: 1e3, easing: "easeOutQuart", onProgress: e.noop, onComplete: e.noop }, t.Animation = t.Element.extend({ currentStep: null, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null }), t.animationService = { frameDuration: 17, animations: [], dropFrames: 0, request: null, addAnimation: function (t, e, i, n) { var o = this; n || (t.animating = !0); for (var a = 0; a < o.animations.length; ++a)if (o.animations[a].chartInstance === t) return void (o.animations[a].animationObject = e); o.animations.push({ chartInstance: t, animationObject: e }), 1 === o.animations.length && o.requestAnimationFrame() }, cancelAnimation: function (t) { var i = e.findIndex(this.animations, function (e) { return e.chartInstance === t }); -1 !== i && (this.animations.splice(i, 1), t.animating = !1) }, requestAnimationFrame: function () { var t = this; null === t.request && (t.request = e.requestAnimFrame.call(window, function () { t.request = null, t.startDigest() })) }, startDigest: function () { var t = this, e = Date.now(), i = 0; t.dropFrames > 1 && (i = Math.floor(t.dropFrames), t.dropFrames = t.dropFrames % 1); for (var n = 0; n < t.animations.length;)null === t.animations[n].animationObject.currentStep && (t.animations[n].animationObject.currentStep = 0), t.animations[n].animationObject.currentStep += 1 + i, t.animations[n].animationObject.currentStep > t.animations[n].animationObject.numSteps && (t.animations[n].animationObject.currentStep = t.animations[n].animationObject.numSteps), t.animations[n].animationObject.render(t.animations[n].chartInstance, t.animations[n].animationObject), t.animations[n].animationObject.onAnimationProgress && t.animations[n].animationObject.onAnimationProgress.call && t.animations[n].animationObject.onAnimationProgress.call(t.animations[n].chartInstance, t.animations[n]), t.animations[n].animationObject.currentStep === t.animations[n].animationObject.numSteps ? (t.animations[n].animationObject.onAnimationComplete && t.animations[n].animationObject.onAnimationComplete.call && t.animations[n].animationObject.onAnimationComplete.call(t.animations[n].chartInstance, t.animations[n]), t.animations[n].chartInstance.animating = !1, t.animations.splice(n, 1)) : ++n; var o = (Date.now() - e) / t.frameDuration; t.dropFrames += o, t.animations.length > 0 && t.requestAnimationFrame() } } } }, {},], 22: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.canvasHelpers = {}; e.drawPoint = function (e, i, n, o, a) { var s, l, u, c, d, h; if ("object" == typeof i && ("[object HTMLImageElement]" === (s = i.toString()) || "[object HTMLCanvasElement]" === s)) return void e.drawImage(i, o - i.width / 2, a - i.height / 2); if (!(isNaN(n) || n <= 0)) { switch (i) { default: e.beginPath(), e.arc(o, a, n, 0, 2 * Math.PI), e.closePath(), e.fill(); break; case "triangle": e.beginPath(), d = (l = 3 * n / Math.sqrt(3)) * Math.sqrt(3) / 2, e.moveTo(o - l / 2, a + d / 3), e.lineTo(o + l / 2, a + d / 3), e.lineTo(o, a - 2 * d / 3), e.closePath(), e.fill(); break; case "rect": h = 1 / Math.SQRT2 * n, e.beginPath(), e.fillRect(o - h, a - h, 2 * h, 2 * h), e.strokeRect(o - h, a - h, 2 * h, 2 * h); break; case "rectRounded": var f = n / Math.SQRT2, p = Math.SQRT2 * n; t.helpers.drawRoundedRectangle(e, o - f, a - f, p, p, n / 2), e.fill(); break; case "rectRot": h = 1 / Math.SQRT2 * n, e.beginPath(), e.moveTo(o - h, a), e.lineTo(o, a + h), e.lineTo(o + h, a), e.lineTo(o, a - h), e.closePath(), e.fill(); break; case "cross": e.beginPath(), e.moveTo(o, a + n), e.lineTo(o, a - n), e.moveTo(o - n, a), e.lineTo(o + n, a), e.closePath(); break; case "crossRot": e.beginPath(), u = Math.cos(Math.PI / 4) * n, c = Math.sin(Math.PI / 4) * n, e.moveTo(o - u, a - c), e.lineTo(o + u, a + c), e.moveTo(o - u, a + c), e.lineTo(o + u, a - c), e.closePath(); break; case "star": e.beginPath(), e.moveTo(o, a + n), e.lineTo(o, a - n), e.moveTo(o - n, a), e.lineTo(o + n, a), u = Math.cos(Math.PI / 4) * n, c = Math.sin(Math.PI / 4) * n, e.moveTo(o - u, a - c), e.lineTo(o + u, a + c), e.moveTo(o - u, a + c), e.lineTo(o + u, a - c), e.closePath(); break; case "line": e.beginPath(), e.moveTo(o - n, a), e.lineTo(o + n, a), e.closePath(); break; case "dash": e.beginPath(), e.moveTo(o, a), e.lineTo(o + n, a), e.closePath() }e.stroke() } }, e.clipArea = function (t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() }, e.unclipArea = function (t) { t.restore() } } }, {},], 23: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers, i = t.plugins, n = t.platform; t.types = {}, t.instances = {}, t.controllers = {}, t.Controller = function (i, o, a) { var s, l, u = this; o = ((l = (s = (s = o) || {}).data = s.data || {}).datasets = l.datasets || [], l.labels = l.labels || [], s.options = e.configMerge(t.defaults.global, t.defaults[s.type], s.options || {}), s); var c = n.acquireContext(i, o), d = c && c.canvas, h = d && d.height, f = d && d.width; return a.ctx = c, a.canvas = d, a.config = o, a.width = f, a.height = h, a.aspectRatio = h ? f / h : null, u.id = e.uid(), u.chart = a, u.config = o, u.options = o.options, u._bufferedRender = !1, t.instances[u.id] = u, Object.defineProperty(u, "data", { get: function () { return u.config.data } }), c && d ? (u.initialize(), u.update(), u) : (console.error("Failed to create chart: can't acquire context from the given item"), u) }, e.extend(t.Controller.prototype, { initialize: function () { return i.notify(this, "beforeInit"), e.retinaScale(this.chart), this.bindEvents(), this.options.responsive && this.resize(!0), this.ensureScalesHaveIDs(), this.buildScales(), this.initToolTip(), i.notify(this, "afterInit"), this }, clear: function () { return e.clear(this.chart), this }, stop: function () { return t.animationService.cancelAnimation(this), this }, resize: function (t) { var n = this.chart, o = this.options, a = n.canvas, s = o.maintainAspectRatio && n.aspectRatio || null, l = Math.floor(e.getMaximumWidth(a)), u = Math.floor(s ? l / s : e.getMaximumHeight(a)); if ((n.width !== l || n.height !== u) && (a.width = n.width = l, a.height = n.height = u, a.style.width = l + "px", a.style.height = u + "px", e.retinaScale(n), !t)) { var c = { width: l, height: u }; i.notify(this, "resize", [c]), this.options.onResize && this.options.onResize(this, c), this.stop(), this.update(this.options.responsiveAnimationDuration) } }, ensureScalesHaveIDs: function () { var t = this.options, i = t.scales || {}, n = t.scale; e.each(i.xAxes, function (t, e) { t.id = t.id || "x-axis-" + e }), e.each(i.yAxes, function (t, e) { t.id = t.id || "y-axis-" + e }), n && (n.id = n.id || "scale") }, buildScales: function () { var i = this, n = i.options, o = i.scales = {}, a = []; n.scales && (a = a.concat((n.scales.xAxes || []).map(function (t) { return { options: t, dtype: "category" } }), (n.scales.yAxes || []).map(function (t) { return { options: t, dtype: "linear" } }))), n.scale && a.push({ options: n.scale, dtype: "radialLinear", isDefault: !0 }), e.each(a, function (n) { var a = n.options, s = e.getValueOrDefault(a.type, n.dtype), l = t.scaleService.getScaleConstructor(s); if (l) { var u = new l({ id: a.id, options: a, ctx: i.chart.ctx, chart: i }); o[u.id] = u, n.isDefault && (i.scale = u) } }), t.scaleService.addScalesToLayout(this) }, buildOrUpdateControllers: function () { var i = this, n = [], o = []; if (e.each(i.data.datasets, function (e, a) { var s = i.getDatasetMeta(a); s.type || (s.type = e.type || i.config.type), n.push(s.type), s.controller ? s.controller.updateIndex(a) : (s.controller = new t.controllers[s.type](i, a), o.push(s.controller)) }, i), n.length > 1) { for (var a = 1; a < n.length; a++)if (n[a] !== n[a - 1]) { i.isCombo = !0; break } } return o }, resetElements: function () { var t = this; e.each(t.data.datasets, function (e, i) { t.getDatasetMeta(i).controller.reset() }, t) }, reset: function () { this.resetElements(), this.tooltip.initialize() }, update: function (t, n) { var o, a, s = this; if ((a = (o = s).options).scale ? o.scale.options = a.scale : a.scales && a.scales.xAxes.concat(a.scales.yAxes).forEach(function (t) { o.scales[t.id].options = t }), o.tooltip._options = a.tooltips, !1 !== i.notify(s, "beforeUpdate")) { s.tooltip._data = s.data; var l = s.buildOrUpdateControllers(); e.each(s.data.datasets, function (t, e) { s.getDatasetMeta(e).controller.buildOrUpdateElements() }, s), s.updateLayout(), e.each(l, function (t) { t.reset() }), s.updateDatasets(), i.notify(s, "afterUpdate"), s._bufferedRender ? s._bufferedRequest = { lazy: n, duration: t } : s.render(t, n) } }, updateLayout: function () { !1 !== i.notify(this, "beforeLayout") && (t.layoutService.update(this, this.chart.width, this.chart.height), i.notify(this, "afterScaleUpdate"), i.notify(this, "afterLayout")) }, updateDatasets: function () { if (!1 !== i.notify(this, "beforeDatasetsUpdate")) { for (var t = 0, e = this.data.datasets.length; t < e; ++t)this.getDatasetMeta(t).controller.update(); i.notify(this, "afterDatasetsUpdate") } }, render: function (n, o) { var a = this; if (!1 !== i.notify(a, "beforeRender")) { var s = a.options.animation, l = function () { i.notify(a, "afterRender"); var t = s && s.onComplete; t && t.call && t.call(a) }; if (s && (void 0 !== n && 0 !== n || void 0 === n && 0 !== s.duration)) { var u = new t.Animation; u.numSteps = (n || s.duration) / 16.66, u.easing = s.easing, u.render = function (t, i) { var n = e.easingEffects[i.easing], o = i.currentStep / i.numSteps, a = n(o); t.draw(a, o, i.currentStep) }, u.onAnimationProgress = s.onProgress, u.onAnimationComplete = l, t.animationService.addAnimation(a, u, n, o) } else a.draw(), l(); return a } }, draw: function (t) { var n = this; n.clear(), null != t || (t = 1), !1 !== i.notify(n, "beforeDraw", [t]) && (e.each(n.boxes, function (t) { t.draw(n.chartArea) }, n), n.scale && n.scale.draw(), n.drawDatasets(t), n.tooltip.transition(t).draw(), i.notify(n, "afterDraw", [t])) }, drawDatasets: function (t) { var n = this; !1 !== i.notify(n, "beforeDatasetsDraw", [t]) && (e.each(n.data.datasets, function (e, i) { n.isDatasetVisible(i) && n.getDatasetMeta(i).controller.draw(t) }, n, !0), i.notify(n, "afterDatasetsDraw", [t])) }, getElementAtEvent: function (e) { return t.Interaction.modes.single(this, e) }, getElementsAtEvent: function (e) { return t.Interaction.modes.label(this, e, { intersect: !0 }) }, getElementsAtXAxis: function (e) { return t.Interaction.modes["x-axis"](this, e, { intersect: !0 }) }, getElementsAtEventForMode: function (e, i, n) { var o = t.Interaction.modes[i]; return "function" == typeof o ? o(this, e, n) : [] }, getDatasetAtEvent: function (e) { return t.Interaction.modes.dataset(this, e, { intersect: !0 }) }, getDatasetMeta: function (t) { var e = this, i = e.data.datasets[t]; i._meta || (i._meta = {}); var n = i._meta[e.id]; return n || (n = i._meta[e.id] = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null }), n }, getVisibleDatasetCount: function () { for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e)this.isDatasetVisible(e) && t++; return t }, isDatasetVisible: function (t) { var e = this.getDatasetMeta(t); return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden }, generateLegend: function () { return this.options.legendCallback(this) }, destroy: function () { var o, a, s, l = this, u = l.chart.canvas; for (l.stop(), a = 0, s = l.data.datasets.length; a < s; ++a)(o = l.getDatasetMeta(a)).controller && (o.controller.destroy(), o.controller = null); u && (l.unbindEvents(), e.clear(l.chart), n.releaseContext(l.chart.ctx), l.chart.canvas = null, l.chart.ctx = null), i.notify(l, "destroy"), delete t.instances[l.id] }, toBase64Image: function () { return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments) }, initToolTip: function () { var e = this; e.tooltip = new t.Tooltip({ _chart: e.chart, _chartInstance: e, _data: e.data, _options: e.options.tooltips }, e), e.tooltip.initialize() }, bindEvents: function () { var t = this, i = t._listeners = {}, o = function () { t.eventHandler.apply(t, arguments) }; e.each(t.options.events, function (e) { n.addEventListener(t, e, o), i[e] = o }), t.options.responsive && (o = function () { t.resize() }, n.addEventListener(t, "resize", o), i.resize = o) }, unbindEvents: function () { var t = this, i = t._listeners; i && (delete t._listeners, e.each(i, function (e, i) { n.removeEventListener(t, i, e) })) }, updateHoverStyle: function (t, e, i) { var n, o, a, s = i ? "setHoverStyle" : "removeHoverStyle"; for (o = 0, a = t.length; o < a; ++o)(n = t[o]) && this.getDatasetMeta(n._datasetIndex).controller[s](n) }, eventHandler: function (t) { var e = this, n = e.tooltip; if (!1 !== i.notify(e, "beforeEvent", [t])) { e._bufferedRender = !0, e._bufferedRequest = null; var o = e.handleEvent(t); o |= n && n.handleEvent(t), i.notify(e, "afterEvent", [t]); var a = e._bufferedRequest; return a ? e.render(a.duration, a.lazy) : o && !e.animating && (e.stop(), e.render(e.options.hover.animationDuration, !0)), e._bufferedRender = !1, e._bufferedRequest = null, e } }, handleEvent: function (t) { var i = this, n = i.options || {}, o = n.hover, a = !1; return i.lastActive = i.lastActive || [], "mouseout" === t.type ? i.active = [] : i.active = i.getElementsAtEventForMode(t, o.mode, o), o.onHover && o.onHover.call(i, t.native, i.active), "mouseup" !== t.type && "click" !== t.type || n.onClick && n.onClick.call(i, t.native, i.active), i.lastActive.length && i.updateHoverStyle(i.lastActive, o.mode, !1), i.active.length && o.mode && i.updateHoverStyle(i.active, o.mode, !0), a = !e.arrayEquals(i.active, i.lastActive), i.lastActive = i.active, a } }) } }, {},], 24: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t, e) { var i = t._chartjs; if (i) { var o = i.listeners, a = o.indexOf(e); -1 !== a && o.splice(a, 1), o.length > 0 || (n.forEach(function (e) { delete t[e] }), delete t._chartjs) } } var i = t.helpers, n = ["push", "pop", "shift", "splice", "unshift"]; t.DatasetController = function (t, e) { this.initialize(t, e) }, i.extend(t.DatasetController.prototype, { datasetElementType: null, dataElementType: null, initialize: function (t, e) { var i = this; i.chart = t, i.index = e, i.linkScales(), i.addElements() }, updateIndex: function (t) { this.index = t }, linkScales: function () { var t = this.getMeta(), e = this.getDataset(); null === t.xAxisID && (t.xAxisID = e.xAxisID || this.chart.options.scales.xAxes[0].id), null === t.yAxisID && (t.yAxisID = e.yAxisID || this.chart.options.scales.yAxes[0].id) }, getDataset: function () { return this.chart.data.datasets[this.index] }, getMeta: function () { return this.chart.getDatasetMeta(this.index) }, getScaleForId: function (t) { return this.chart.scales[t] }, reset: function () { this.update(!0) }, destroy: function () { this._data && e(this._data, this) }, createMetaDataset: function () { var t = this.datasetElementType; return t && new t({ _chart: this.chart.chart, _datasetIndex: this.index }) }, createMetaData: function (t) { var e = this.dataElementType; return e && new e({ _chart: this.chart.chart, _datasetIndex: this.index, _index: t }) }, addElements: function () { var t, e, i = this.getMeta(), n = this.getDataset().data || [], o = i.data; for (t = 0, e = n.length; t < e; ++t)o[t] = o[t] || this.createMetaData(t); i.dataset = i.dataset || this.createMetaDataset() }, addElementAndReset: function (t) { var e = this.createMetaData(t); this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0) }, buildOrUpdateElements: function () { var t, o, a = this, s = a.getDataset(), l = s.data || (s.data = []); a._data !== l && (a._data && e(a._data, a), t = l, o = a, t._chartjs ? t._chartjs.listeners.push(o) : (Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [o] } }), n.forEach(function (e) { var n = "onData" + e.charAt(0).toUpperCase() + e.slice(1), o = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: function () { var e = Array.prototype.slice.call(arguments), a = o.apply(this, e); return i.each(t._chartjs.listeners, function (t) { "function" == typeof t[n] && t[n].apply(t, e) }), a } }) })), a._data = l), a.resyncElements() }, update: i.noop, draw: function (t) { var e, i, n = t || 1, o = this.getMeta().data; for (e = 0, i = o.length; e < i; ++e)o[e].transition(n).draw() }, removeHoverStyle: function (t, e) { var n = this.chart.data.datasets[t._datasetIndex], o = t._index, a = t.custom || {}, s = i.getValueAtIndexOrDefault, l = t._model; l.backgroundColor = a.backgroundColor ? a.backgroundColor : s(n.backgroundColor, o, e.backgroundColor), l.borderColor = a.borderColor ? a.borderColor : s(n.borderColor, o, e.borderColor), l.borderWidth = a.borderWidth ? a.borderWidth : s(n.borderWidth, o, e.borderWidth) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], n = t._index, o = t.custom || {}, a = i.getValueAtIndexOrDefault, s = i.getHoverColor, l = t._model; l.backgroundColor = o.hoverBackgroundColor ? o.hoverBackgroundColor : a(e.hoverBackgroundColor, n, s(l.backgroundColor)), l.borderColor = o.hoverBorderColor ? o.hoverBorderColor : a(e.hoverBorderColor, n, s(l.borderColor)), l.borderWidth = o.hoverBorderWidth ? o.hoverBorderWidth : a(e.hoverBorderWidth, n, l.borderWidth) }, resyncElements: function () { var t = this.getMeta(), e = this.getDataset().data, i = t.data.length, n = e.length; n < i ? t.data.splice(n, i - n) : n > i && this.insertElements(i, n - i) }, insertElements: function (t, e) { for (var i = 0; i < e; ++i)this.addElementAndReset(t + i) }, onDataPush: function () { this.insertElements(this.getDataset().data.length - 1, arguments.length) }, onDataPop: function () { this.getMeta().data.pop() }, onDataShift: function () { this.getMeta().data.shift() }, onDataSplice: function (t, e) { this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2) }, onDataUnshift: function () { this.insertElements(0, arguments.length) } }), t.DatasetController.extend = i.inherits } }, {},], 25: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.elements = {}, t.Element = function (t) { e.extend(this, t), this.initialize.apply(this, arguments) }, e.extend(t.Element.prototype, { initialize: function () { this.hidden = !1 }, pivot: function () { var t = this; return t._view || (t._view = e.clone(t._model)), t._start = e.clone(t._view), t }, transition: function (t) { var i = this; return i._view || (i._view = e.clone(i._model)), 1 === t ? (i._view = i._model, i._start = null, i) : (i._start || i.pivot(), e.each(i._model, function (n, o) { if ("_" === o[0]); else if (i._view.hasOwnProperty(o)) { if (n === i._view[o]); else if ("string" == typeof n) try { var a = e.color(i._model[o]).mix(e.color(i._start[o]), t); i._view[o] = a.rgbString() } catch (s) { i._view[o] = n } else if ("number" == typeof n) { var l = void 0 !== i._start[o] && !1 === isNaN(i._start[o]) ? i._start[o] : 0; i._view[o] = (i._model[o] - l) * t + l } else i._view[o] = n } else "number" != typeof n || isNaN(i._view[o]) ? i._view[o] = n : i._view[o] = n * t }, i), i) }, tooltipPosition: function () { return { x: this._model.x, y: this._model.y } }, hasValue: function () { return e.isNumber(this._model.x) && e.isNumber(this._model.y) } }), t.Element.extend = e.inherits } }, {},], 26: [function (t, e, i) { "use strict"; var n = t(3); e.exports = function (t) { function e(t, e, i) { var n; return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n } function i(t) { return null != t && "none" !== t } function o(t, n, o) { var a = document.defaultView, s = t.parentNode, l = a.getComputedStyle(t)[n], u = a.getComputedStyle(s)[n], c = i(l), d = i(u), h = Number.POSITIVE_INFINITY; return c || d ? Math.min(c ? e(l, t, o) : h, d ? e(u, s, o) : h) : "none" } var a, s = t.helpers = {}; s.each = function (t, e, i, n) { var o, a; if (s.isArray(t)) { if (a = t.length, n) for (o = a - 1; o >= 0; o--)e.call(i, t[o], o); else for (o = 0; o < a; o++)e.call(i, t[o], o) } else if ("object" == typeof t) { var l = Object.keys(t); for (a = l.length, o = 0; o < a; o++)e.call(i, t[l[o]], l[o]) } }, s.clone = function (t) { var e = {}; return s.each(t, function (t, i) { s.isArray(t) ? e[i] = t.slice(0) : "object" == typeof t && null !== t ? e[i] = s.clone(t) : e[i] = t }), e }, s.extend = function (t) { for (var e = function (e, i) { t[i] = e }, i = 1, n = arguments.length; i < n; i++)s.each(arguments[i], e); return t }, s.configMerge = function (e) { var i = s.clone(e); return s.each(Array.prototype.slice.call(arguments, 1), function (e) { s.each(e, function (e, n) { var o = i.hasOwnProperty(n), a = o ? i[n] : {}; "scales" === n ? i[n] = s.scaleMerge(a, e) : "scale" === n ? i[n] = s.configMerge(a, t.scaleService.getScaleDefaults(e.type), e) : !o || "object" != typeof a || s.isArray(a) || null === a || "object" != typeof e || s.isArray(e) ? i[n] = e : i[n] = s.configMerge(a, e) }) }), i }, s.scaleMerge = function (e, i) { var n = s.clone(e); return s.each(i, function (e, i) { "xAxes" === i || "yAxes" === i ? n.hasOwnProperty(i) ? s.each(e, function (e, o) { var a = s.getValueOrDefault(e.type, "xAxes" === i ? "category" : "linear"), l = t.scaleService.getScaleDefaults(a); o >= n[i].length || !n[i][o].type ? n[i].push(s.configMerge(l, e)) : e.type && e.type !== n[i][o].type ? n[i][o] = s.configMerge(n[i][o], l, e) : n[i][o] = s.configMerge(n[i][o], e) }) : (n[i] = [], s.each(e, function (e) { var o = s.getValueOrDefault(e.type, "xAxes" === i ? "category" : "linear"); n[i].push(s.configMerge(t.scaleService.getScaleDefaults(o), e)) })) : n.hasOwnProperty(i) && "object" == typeof n[i] && null !== n[i] && "object" == typeof e ? n[i] = s.configMerge(n[i], e) : n[i] = e }), n }, s.getValueAtIndexOrDefault = function (t, e, i) { return null == t ? i : s.isArray(t) ? e < t.length ? t[e] : i : t }, s.getValueOrDefault = function (t, e) { return void 0 === t ? e : t }, s.indexOf = Array.prototype.indexOf ? function (t, e) { return t.indexOf(e) } : function (t, e) { for (var i = 0, n = t.length; i < n; ++i)if (t[i] === e) return i; return -1 }, s.where = function (t, e) { if (s.isArray(t) && Array.prototype.filter) return t.filter(e); var i = []; return s.each(t, function (t) { e(t) && i.push(t) }), i }, s.findIndex = Array.prototype.findIndex ? function (t, e, i) { return t.findIndex(e, i) } : function (t, e, i) { i = void 0 === i ? t : i; for (var n = 0, o = t.length; n < o; ++n)if (e.call(i, t[n], n, t)) return n; return -1 }, s.findNextWhere = function (t, e, i) { null != i || (i = -1); for (var n = i + 1; n < t.length; n++) { var o = t[n]; if (e(o)) return o } }, s.findPreviousWhere = function (t, e, i) { null != i || (i = t.length); for (var n = i - 1; n >= 0; n--) { var o = t[n]; if (e(o)) return o } }, s.inherits = function (t) { var e = this, i = t && t.hasOwnProperty("constructor") ? t.constructor : function () { return e.apply(this, arguments) }, n = function () { this.constructor = i }; return n.prototype = e.prototype, i.prototype = new n, i.extend = s.inherits, t && s.extend(i.prototype, t), i.__super__ = e.prototype, i }, s.noop = function () { }, s.uid = (a = 0, function () { return a++ }), s.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t) }, s.almostEquals = function (t, e, i) { return Math.abs(t - e) < i }, s.almostWhole = function (t, e) { var i = Math.round(t); return i - e < t && i + e > t }, s.max = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.max(t, e) }, Number.NEGATIVE_INFINITY) }, s.min = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.min(t, e) }, Number.POSITIVE_INFINITY) }, s.sign = Math.sign ? function (t) { return Math.sign(t) } : function (t) { return 0 == (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1 }, s.log10 = Math.log10 ? function (t) { return Math.log10(t) } : function (t) { return Math.log(t) / Math.LN10 }, s.toRadians = function (t) { return t * (Math.PI / 180) }, s.toDegrees = function (t) { return t * (180 / Math.PI) }, s.getAngleFromPoint = function (t, e) { var i = e.x - t.x, n = e.y - t.y, o = Math.atan2(n, i); return o < -.5 * Math.PI && (o += 2 * Math.PI), { angle: o, distance: Math.sqrt(i * i + n * n) } }, s.distanceBetweenPoints = function (t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) }, s.aliasPixel = function (t) { return t % 2 == 0 ? 0 : .5 }, s.splineCurve = function (t, e, i, n) { var o = t.skip ? e : t, a = e, s = i.skip ? e : i, l = Math.sqrt(Math.pow(a.x - o.x, 2) + Math.pow(a.y - o.y, 2)), u = Math.sqrt(Math.pow(s.x - a.x, 2) + Math.pow(s.y - a.y, 2)), c = l / (l + u), d = u / (l + u); c = isNaN(c) ? 0 : c, d = isNaN(d) ? 0 : d; var h = n * c, f = n * d; return { previous: { x: a.x - h * (s.x - o.x), y: a.y - h * (s.y - o.y) }, next: { x: a.x + f * (s.x - o.x), y: a.y + f * (s.y - o.y) } } }, s.EPSILON = Number.EPSILON || 1e-14, s.splineCurveMonotone = function (t) { var e, i, n, o, a, l, u, c, d, h = (t || []).map(function (t) { return { model: t._model, deltaK: 0, mK: 0 } }), f = h.length; for (l = 0; l < f; ++l)if (!(c = h[l]).model.skip) { if (u = l > 0 ? h[l - 1] : null, (d = l < f - 1 ? h[l + 1] : null) && !d.model.skip) { var p = d.model.x - c.model.x; c.deltaK = 0 !== p ? (d.model.y - c.model.y) / p : 0 } !u || u.model.skip ? c.mK = c.deltaK : !d || d.model.skip ? c.mK = u.deltaK : this.sign(u.deltaK) !== this.sign(c.deltaK) ? c.mK = 0 : c.mK = (u.deltaK + c.deltaK) / 2 } for (l = 0; l < f - 1; ++l)c = h[l], d = h[l + 1], c.model.skip || d.model.skip || (s.almostEquals(c.deltaK, 0, this.EPSILON) ? c.mK = d.mK = 0 : (o = Math.pow(e = c.mK / c.deltaK, 2) + Math.pow(i = d.mK / c.deltaK, 2)) <= 9 || (n = 3 / Math.sqrt(o), c.mK = e * n * c.deltaK, d.mK = i * n * c.deltaK)); for (l = 0; l < f; ++l)(c = h[l]).model.skip || (u = l > 0 ? h[l - 1] : null, d = l < f - 1 ? h[l + 1] : null, u && !u.model.skip && (a = (c.model.x - u.model.x) / 3, c.model.controlPointPreviousX = c.model.x - a, c.model.controlPointPreviousY = c.model.y - a * c.mK), d && !d.model.skip && (a = (d.model.x - c.model.x) / 3, c.model.controlPointNextX = c.model.x + a, c.model.controlPointNextY = c.model.y + a * c.mK)) }, s.nextItem = function (t, e, i) { return i ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1] }, s.previousItem = function (t, e, i) { return i ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1] }, s.niceNum = function (t, e) { var i, n = Math.floor(s.log10(t)), o = t / Math.pow(10, n); return (i = e ? o < 1.5 ? 1 : o < 3 ? 2 : o < 7 ? 5 : 10 : o <= 1 ? 1 : o <= 2 ? 2 : o <= 5 ? 5 : 10) * Math.pow(10, n) }; var l = s.easingEffects = { linear: function (t) { return t }, easeInQuad: function (t) { return t * t }, easeOutQuad: function (t) { return -1 * t * (t - 2) }, easeInOutQuad: function (t) { return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) }, easeInCubic: function (t) { return t * t * t }, easeOutCubic: function (t) { return 1 * ((t = t / 1 - 1) * t * t + 1) }, easeInOutCubic: function (t) { return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) }, easeInQuart: function (t) { return t * t * t * t }, easeOutQuart: function (t) { return -1 * ((t = t / 1 - 1) * t * t * t - 1) }, easeInOutQuart: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) }, easeInQuint: function (t) { return 1 * (t /= 1) * t * t * t * t }, easeOutQuint: function (t) { return 1 * ((t = t / 1 - 1) * t * t * t * t + 1) }, easeInOutQuint: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) }, easeInSine: function (t) { return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1 }, easeOutSine: function (t) { return 1 * Math.sin(t / 1 * (Math.PI / 2)) }, easeInOutSine: function (t) { return -.5 * (Math.cos(Math.PI * t / 1) - 1) }, easeInExpo: function (t) { return 0 === t ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1)) }, easeOutExpo: function (t) { return 1 === t ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1) }, easeInOutExpo: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (-Math.pow(2, -10 * --t) + 2) }, easeInCirc: function (t) { return t >= 1 ? t : -1 * (Math.sqrt(1 - (t /= 1) * t) - 1) }, easeOutCirc: function (t) { return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t) }, easeInOutCirc: function (t) { return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, easeInElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 1 == (t /= 1) ? 1 : (i || (i = .3), n < Math.abs(1) ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), -(n * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / i))) }, easeOutElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 1 == (t /= 1) ? 1 : (i || (i = .3), n < Math.abs(1) ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((1 * t - e) * (2 * Math.PI) / i) + 1) }, easeInOutElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (i || (i = 1 * (.3 * 1.5)), n < Math.abs(1) ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? -.5 * (n * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / i)) : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / i) * .5 + 1) }, easeInBack: function (t) { return 1 * (t /= 1) * t * (2.70158 * t - 1.70158) }, easeOutBack: function (t) { return 1 * ((t = t / 1 - 1) * t * (2.70158 * t + 1.70158) + 1) }, easeInOutBack: function (t) { var e = 1.70158; return (t /= .5) < 1 ? .5 * (t * t * (((e *= 1.525) + 1) * t - e)) : .5 * ((t -= 2) * t * (((e *= 1.525) + 1) * t + e) + 2) }, easeInBounce: function (t) { return 1 - l.easeOutBounce(1 - t) }, easeOutBounce: function (t) { return (t /= 1) < 1 / 2.75 ? 1 * (7.5625 * t * t) : t < 2 / 2.75 ? 1 * (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) }, easeInOutBounce: function (t) { return t < .5 ? .5 * l.easeInBounce(2 * t) : .5 * l.easeOutBounce(2 * t - 1) + .5 } }; s.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60) }, s.getRelativePosition = function (t, e) { var i, n, o = t.originalEvent || t, a = t.currentTarget || t.srcElement, l = a.getBoundingClientRect(), u = o.touches; u && u.length > 0 ? (i = u[0].clientX, n = u[0].clientY) : (i = o.clientX, n = o.clientY); var c = parseFloat(s.getStyle(a, "padding-left")), d = parseFloat(s.getStyle(a, "padding-top")), h = parseFloat(s.getStyle(a, "padding-right")), f = parseFloat(s.getStyle(a, "padding-bottom")), p = l.right - l.left - c - h, $ = l.bottom - l.top - d - f; return { x: i = Math.round((i - l.left - c) / p * a.width / e.currentDevicePixelRatio), y: n = Math.round((n - l.top - d) / $ * a.height / e.currentDevicePixelRatio) } }, s.addEvent = function (t, e, i) { t.addEventListener ? t.addEventListener(e, i) : t.attachEvent ? t.attachEvent("on" + e, i) : t["on" + e] = i }, s.removeEvent = function (t, e, i) { t.removeEventListener ? t.removeEventListener(e, i, !1) : t.detachEvent ? t.detachEvent("on" + e, i) : t["on" + e] = s.noop }, s.getConstraintWidth = function (t) { return o(t, "max-width", "clientWidth") }, s.getConstraintHeight = function (t) { return o(t, "max-height", "clientHeight") }, s.getMaximumWidth = function (t) { var e = t.parentNode, i = parseInt(s.getStyle(e, "padding-left"), 10), n = parseInt(s.getStyle(e, "padding-right"), 10), o = e.clientWidth - i - n, a = s.getConstraintWidth(t); return isNaN(a) ? o : Math.min(o, a) }, s.getMaximumHeight = function (t) { var e = t.parentNode, i = parseInt(s.getStyle(e, "padding-top"), 10), n = parseInt(s.getStyle(e, "padding-bottom"), 10), o = e.clientHeight - i - n, a = s.getConstraintHeight(t); return isNaN(a) ? o : Math.min(o, a) }, s.getStyle = function (t, e) { return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e) }, s.retinaScale = function (t) { var e = t.currentDevicePixelRatio = window.devicePixelRatio || 1; if (1 !== e) { var i = t.canvas, n = t.height, o = t.width; i.height = n * e, i.width = o * e, t.ctx.scale(e, e), i.style.height = n + "px", i.style.width = o + "px" } }, s.clear = function (t) { t.ctx.clearRect(0, 0, t.width, t.height) }, s.fontString = function (t, e, i) { return e + " " + t + "px " + i }, s.longestText = function (t, e, i, n) { var o = (n = n || {}).data = n.data || {}, a = n.garbageCollect = n.garbageCollect || []; n.font !== e && (o = n.data = {}, a = n.garbageCollect = [], n.font = e), t.font = e; var l = 0; s.each(i, function (e) { null != e && !0 !== s.isArray(e) ? l = s.measureText(t, o, a, l, e) : s.isArray(e) && s.each(e, function (e) { null == e || s.isArray(e) || (l = s.measureText(t, o, a, l, e)) }) }); var u = a.length / 2; if (u > i.length) { for (var c = 0; c < u; c++)delete o[a[c]]; a.splice(0, u) } return l }, s.measureText = function (t, e, i, n, o) { var a = e[o]; return a || (a = e[o] = t.measureText(o).width, i.push(o)), a > n && (n = a), n }, s.numberOfLabelLines = function (t) { var e = 1; return s.each(t, function (t) { s.isArray(t) && t.length > e && (e = t.length) }), e }, s.drawRoundedRectangle = function (t, e, i, n, o, a) { t.beginPath(), t.moveTo(e + a, i), t.lineTo(e + n - a, i), t.quadraticCurveTo(e + n, i, e + n, i + a), t.lineTo(e + n, i + o - a), t.quadraticCurveTo(e + n, i + o, e + n - a, i + o), t.lineTo(e + a, i + o), t.quadraticCurveTo(e, i + o, e, i + o - a), t.lineTo(e, i + a), t.quadraticCurveTo(e, i, e + a, i), t.closePath() }, s.color = function (e) { return n ? n(e instanceof CanvasGradient ? t.defaults.global.defaultColor : e) : (console.error("Color.js not found!"), e) }, s.isArray = Array.isArray ? function (t) { return Array.isArray(t) } : function (t) { return "[object Array]" === Object.prototype.toString.call(t) }, s.arrayEquals = function (t, e) { var i, n, o, a; if (!t || !e || t.length !== e.length) return !1; for (i = 0, n = t.length; i < n; ++i)if (o = t[i], a = e[i], o instanceof Array && a instanceof Array) { if (!s.arrayEquals(o, a)) return !1 } else if (o !== a) return !1; return !0 }, s.callCallback = function (t, e, i) { t && "function" == typeof t.call && t.apply(i, e) }, s.getHoverColor = function (t) { return t instanceof CanvasPattern ? t : s.color(t).saturate(.5).darken(.1).rgbString() } } }, { 3: 3 },], 27: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t, e) { return t.native ? { x: t.x, y: t.y } : s.getRelativePosition(t, e) } function i(t, e) { var i, n, o, a, s, l = t.data.datasets; for (n = 0, a = l.length; n < a; ++n)if (t.isDatasetVisible(n)) for (i = t.getDatasetMeta(n), o = 0, s = i.data.length; o < s; ++o) { var u = i.data[o]; u._view.skip || e(u) } } function n(t, e) { var n = []; return i(t, function (t) { t.inRange(e.x, e.y) && n.push(t) }), n } function o(t, e, n, o) { var a = Number.POSITIVE_INFINITY, l = []; return o || (o = s.distanceBetweenPoints), i(t, function (t) { if (!n || t.inRange(e.x, e.y)) { var i = o(e, t.getCenterPoint()); i < a ? (l = [t], a = i) : i === a && l.push(t) } }), l } function a(t, i, a) { var s = e(i, t.chart), l = function (t, e) { return Math.abs(t.x - e.x) }, u = a.intersect ? n(t, s) : o(t, s, !1, l), c = []; return u.length ? (t.data.datasets.forEach(function (e, i) { if (t.isDatasetVisible(i)) { var n = t.getDatasetMeta(i).data[u[0]._index]; n && !n._view.skip && c.push(n) } }), c) : [] } var s = t.helpers; t.Interaction = { modes: { single: function (t, n) { var o = e(n, t.chart), a = []; return i(t, function (t) { if (t.inRange(o.x, o.y)) return a.push(t), a }), a.slice(0, 1) }, label: a, index: a, dataset: function (t, i, a) { var s = e(i, t.chart), l = a.intersect ? n(t, s) : o(t, s, !1); return l.length > 0 && (l = t.getDatasetMeta(l[0]._datasetIndex).data), l }, "x-axis": function (t, e) { return a(t, e, !0) }, point: function (t, i) { var o = e(i, t.chart); return n(t, o) }, nearest: function (t, i, n) { var a = e(i, t.chart), s = o(t, a, n.intersect); return s.length > 1 && s.sort(function (t, e) { var i, n = t.getArea() - e.getArea(); return 0 === n && (n = t._datasetIndex - e._datasetIndex), n }), s.slice(0, 1) }, x: function (t, n, o) { var a = e(n, t.chart), s = [], l = !1; return i(t, function (t) { t.inXRange(a.x) && s.push(t), t.inRange(a.x, a.y) && (l = !0) }), o.intersect && !l && (s = []), s }, y: function (t, n, o) { var a = e(n, t.chart), s = [], l = !1; return i(t, function (t) { t.inYRange(a.y) && s.push(t), t.inRange(a.x, a.y) && (l = !0) }), o.intersect && !l && (s = []), s } } } } }, {},], 28: [function (t, e, i) { "use strict"; e.exports = function () { var t = function (e, i) { return this.controller = new t.Controller(e, i, this), this.controller }; return t.defaults = { global: { responsive: !0, responsiveAnimationDuration: 0, maintainAspectRatio: !0, events: ["mousemove", "mouseout", "click", "touchstart", "touchmove",], hover: { onHover: null, mode: "nearest", intersect: !0, animationDuration: 400 }, onClick: null, defaultColor: "rgba(0,0,0,0.1)", defaultFontColor: "#666", defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", defaultFontSize: 12, defaultFontStyle: "normal", showLines: !0, elements: {}, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); for (var i = 0; i < t.data.datasets.length; i++)e.push('<li><span style="background-color:' + t.data.datasets[i].backgroundColor + '"></span>'), t.data.datasets[i].label && e.push(t.data.datasets[i].label), e.push("</li>"); return e.push("</ul>"), e.join("") } } }, t.Chart = t, t } }, {},], 29: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.layoutService = { defaults: {}, addBox: function (t, e) { t.boxes || (t.boxes = []), t.boxes.push(e) }, removeBox: function (t, e) { t.boxes && t.boxes.splice(t.boxes.indexOf(e), 1) }, update: function (t, i, n) { function o(t) { var i = e.findNextWhere(D, function (e) { return e.box === t }); if (i) { if (t.isHorizontal()) { var n = { left: Math.max(F, I), right: Math.max(V, A), top: 0, bottom: 0 }; t.update(t.options.fullWidth ? _ : w, x / 2, n) } else t.update(i.minSize.width, C) } } function a(t) { t.isHorizontal() ? (t.left = t.options.fullWidth ? u : F, t.right = t.options.fullWidth ? i - c : F + w, t.top = E, t.bottom = E + t.height, E = t.bottom) : (t.left = M, t.right = M + t.width, t.top = R, t.bottom = R + C, M = t.right) } if (t) { var s = t.options.layout, l = s ? s.padding : null, u = 0, c = 0, d = 0, h = 0; isNaN(l) ? (u = l.left || 0, c = l.right || 0, d = l.top || 0, h = l.bottom || 0) : (u = l, c = l, d = l, h = l); var f = e.where(t.boxes, function (t) { return "left" === t.options.position }), p = e.where(t.boxes, function (t) { return "right" === t.options.position }), $ = e.where(t.boxes, function (t) { return "top" === t.options.position }), m = e.where(t.boxes, function (t) { return "bottom" === t.options.position }), v = e.where(t.boxes, function (t) { return "chartArea" === t.options.position }); $.sort(function (t, e) { return (e.options.fullWidth ? 1 : 0) - (t.options.fullWidth ? 1 : 0) }), m.sort(function (t, e) { return (t.options.fullWidth ? 1 : 0) - (e.options.fullWidth ? 1 : 0) }); var _ = i - u - c, x = n - d - h, y = x / 2, k = (i - _ / 2) / (f.length + p.length), S = (n - y) / ($.length + m.length), w = _, C = x, D = []; e.each(f.concat(p, $, m), function t(e) { var i, n = e.isHorizontal(); n ? C -= (i = e.update(e.options.fullWidth ? _ : w, S)).height : w -= (i = e.update(k, y)).width, D.push({ horizontal: n, minSize: i, box: e }) }); var I = 0, A = 0, P = 0, T = 0; e.each($.concat(m), function (t) { if (t.getPadding) { var e = t.getPadding(); I = Math.max(I, e.left), A = Math.max(A, e.right) } }), e.each(f.concat(p), function (t) { if (t.getPadding) { var e = t.getPadding(); P = Math.max(P, e.top), T = Math.max(T, e.bottom) } }); var F = u, V = c, R = d, L = h; e.each(f.concat(p), o), e.each(f, function (t) { F += t.width }), e.each(p, function (t) { V += t.width }), e.each($.concat(m), o), e.each($, function (t) { R += t.height }), e.each(m, function (t) { L += t.height }), e.each(f.concat(p), function t(i) { var n = e.findNextWhere(D, function (t) { return t.box === i }), o = { left: 0, right: 0, top: R, bottom: L }; n && i.update(n.minSize.width, C, o) }), F = u, V = c, R = d, L = h, e.each(f, function (t) { F += t.width }), e.each(p, function (t) { V += t.width }), e.each($, function (t) { R += t.height }), e.each(m, function (t) { L += t.height }); var O = Math.max(I - F, 0); F += O, V += Math.max(A - V, 0); var B = Math.max(P - R, 0), z = n - (R += B) - (L += Math.max(T - L, 0)), W = i - F - V; W === w && z === C || (e.each(f, function (t) { t.height = z }), e.each(p, function (t) { t.height = z }), e.each($, function (t) { t.options.fullWidth || (t.width = W) }), e.each(m, function (t) { t.options.fullWidth || (t.width = W) }), C = z, w = W); var M = u + O, E = d + B; e.each(f.concat($), a), M += w, E += C, e.each(p, a), e.each(m, a), t.chartArea = { left: F, top: R, right: F + w, bottom: R + C }, e.each(v, function (e) { e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(w, C) }) } } } } }, {},], 30: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t, e) { return t.usePointStyle ? e * Math.SQRT2 : t.boxWidth } function i(e, i) { var n = new t.Legend({ ctx: e.chart.ctx, options: i, chart: e }); e.legend = n, t.layoutService.addBox(e, n) } var n = t.helpers, o = n.noop; t.defaults.global.legend = { display: !0, position: "top", fullWidth: !0, reverse: !1, onClick: function (t, e) { var i = e.datasetIndex, n = this.chart, o = n.getDatasetMeta(i); o.hidden = null === o.hidden ? !n.data.datasets[i].hidden : null, n.update() }, onHover: null, labels: { boxWidth: 40, padding: 10, generateLabels: function (t) { var e = t.data; return n.isArray(e.datasets) ? e.datasets.map(function (e, i) { return { text: e.label, fillStyle: n.isArray(e.backgroundColor) ? e.backgroundColor[0] : e.backgroundColor, hidden: !t.isDatasetVisible(i), lineCap: e.borderCapStyle, lineDash: e.borderDash, lineDashOffset: e.borderDashOffset, lineJoin: e.borderJoinStyle, lineWidth: e.borderWidth, strokeStyle: e.borderColor, pointStyle: e.pointStyle, datasetIndex: i } }, this) : [] } } }, t.Legend = t.Element.extend({ initialize: function (t) { n.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1 }, beforeUpdate: o, update: function (t, e, i) { var n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize }, afterUpdate: o, beforeSetDimensions: o, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 } }, afterSetDimensions: o, beforeBuildLabels: o, buildLabels: function () { var t = this, e = t.options.labels, i = e.generateLabels.call(t, t.chart); e.filter && (i = i.filter(function (i) { return e.filter(i, t.chart.data) })), t.options.reverse && i.reverse(), t.legendItems = i }, afterBuildLabels: o, beforeFit: o, fit: function () { var i = this, o = i.options, a = o.labels, s = o.display, l = i.ctx, u = t.defaults.global, c = n.getValueOrDefault, d = c(a.fontSize, u.defaultFontSize), h = c(a.fontStyle, u.defaultFontStyle), f = c(a.fontFamily, u.defaultFontFamily), p = n.fontString(d, h, f), $ = i.legendHitBoxes = [], m = i.minSize, v = i.isHorizontal(); if (v ? (m.width = i.maxWidth, m.height = s ? 10 : 0) : (m.width = s ? 10 : 0, m.height = i.maxHeight), s) { if (l.font = p, v) { var _ = i.lineWidths = [0], x = i.legendItems.length ? d + a.padding : 0; l.textAlign = "left", l.textBaseline = "top", n.each(i.legendItems, function (t, n) { var o = e(a, d) + d / 2 + l.measureText(t.text).width; _[_.length - 1] + o + a.padding >= i.width && (x += d + a.padding, _[_.length] = i.left), $[n] = { left: 0, top: 0, width: o, height: d }, _[_.length - 1] += o + a.padding }), m.height += x } else { var y = a.padding, k = i.columnWidths = [], S = a.padding, w = 0, C = 0, D = d + y; n.each(i.legendItems, function (t, i) { var n = e(a, d) + d / 2 + l.measureText(t.text).width; C + D > m.height && (S += w + a.padding, k.push(w), w = 0, C = 0), w = Math.max(w, n), C += D, $[i] = { left: 0, top: 0, width: n, height: d } }), S += w, k.push(w), m.width += S } } i.width = m.width, i.height = m.height }, afterFit: o, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position }, draw: function () { var i = this, o = i.options, a = o.labels, s = t.defaults.global, l = s.elements.line, u = i.width, c = i.lineWidths; if (o.display) { var d, h = i.ctx, f = n.getValueOrDefault, p = f(a.fontColor, s.defaultFontColor), $ = f(a.fontSize, s.defaultFontSize), m = f(a.fontStyle, s.defaultFontStyle), v = f(a.fontFamily, s.defaultFontFamily), _ = n.fontString($, m, v); h.textAlign = "left", h.textBaseline = "top", h.lineWidth = .5, h.strokeStyle = p, h.fillStyle = p, h.font = _; var x = e(a, $), y = i.legendHitBoxes, k = function (e, i, n) { if (!(isNaN(x) || x <= 0)) { h.save(), h.fillStyle = f(n.fillStyle, s.defaultColor), h.lineCap = f(n.lineCap, l.borderCapStyle), h.lineDashOffset = f(n.lineDashOffset, l.borderDashOffset), h.lineJoin = f(n.lineJoin, l.borderJoinStyle), h.lineWidth = f(n.lineWidth, l.borderWidth), h.strokeStyle = f(n.strokeStyle, s.defaultColor); var a = 0 === f(n.lineWidth, l.borderWidth); if (h.setLineDash && h.setLineDash(f(n.lineDash, l.borderDash)), o.labels && o.labels.usePointStyle) { var u = $ * Math.SQRT2 / 2, c = u / Math.SQRT2; t.canvasHelpers.drawPoint(h, n.pointStyle, u, e + c, i + c) } else a || h.strokeRect(e, i, x, $), h.fillRect(e, i, x, $); h.restore() } }, S = function (t, e, i, n) { h.fillText(i.text, x + $ / 2 + t, e), i.hidden && (h.beginPath(), h.lineWidth = 2, h.moveTo(x + $ / 2 + t, e + $ / 2), h.lineTo(x + $ / 2 + t + n, e + $ / 2), h.stroke()) }, w = i.isHorizontal(); d = w ? { x: i.left + (u - c[0]) / 2, y: i.top + a.padding, line: 0 } : { x: i.left + a.padding, y: i.top + a.padding, line: 0 }; var C = $ + a.padding; n.each(i.legendItems, function (t, e) { var n = h.measureText(t.text).width, o = x + $ / 2 + n, s = d.x, l = d.y; w ? s + o >= u && (l = d.y += C, d.line++, s = d.x = i.left + (u - c[d.line]) / 2) : l + C > i.bottom && (s = d.x = s + i.columnWidths[d.line] + a.padding, l = d.y = i.top + a.padding, d.line++), k(s, l, t), y[e].left = s, y[e].top = l, S(s, l, t, n), w ? d.x += o + a.padding : d.y += C }) } }, handleEvent: function (t) { var e = this.options, i = "mouseup" === t.type ? "click" : t.type, n = !1; if ("mousemove" === i) { if (!e.onHover) return } else if ("click" !== i || !e.onClick) return; var o = t.x, a = t.y; if (o >= this.left && o <= this.right && a >= this.top && a <= this.bottom) for (var s = this.legendHitBoxes, l = 0; l < s.length; ++l) { var u = s[l]; if (o >= u.left && o <= u.left + u.width && a >= u.top && a <= u.top + u.height) { if ("click" === i) { e.onClick.call(this, t.native, this.legendItems[l]), n = !0; break } if ("mousemove" === i) { e.onHover.call(this, t.native, this.legendItems[l]), n = !0; break } } } return n } }), t.plugins.register({ beforeInit: function (t) { var e = t.options.legend; e && i(t, e) }, beforeUpdate: function (e) { var o = e.options.legend; o ? (o = n.configMerge(t.defaults.global.legend, o), e.legend ? e.legend.options = o : i(e, o)) : (t.layoutService.removeBox(e, e.legend), delete e.legend) }, afterEvent: function (t, e) { var i = t.legend; i && i.handleEvent(e) } }) } }, {},], 31: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.defaults.global.plugins = {}, t.plugins = { _plugins: [], _cacheId: 0, register: function (t) { var e = this._plugins;[].concat(t).forEach(function (t) { -1 === e.indexOf(t) && e.push(t) }), this._cacheId++ }, unregister: function (t) { var e = this._plugins;[].concat(t).forEach(function (t) { var i = e.indexOf(t); -1 !== i && e.splice(i, 1) }), this._cacheId++ }, clear: function () { this._plugins = [], this._cacheId++ }, count: function () { return this._plugins.length }, getAll: function () { return this._plugins }, notify: function (t, e, i) { var n, o, a, s, l, u = this.descriptors(t), c = u.length; for (n = 0; n < c; ++n)if ("function" == typeof (l = (a = (o = u[n]).plugin)[e]) && ((s = [t].concat(i || [])).push(o.options), !1 === l.apply(a, s))) return !1; return !0 }, descriptors: function (i) { var n = i._plugins || (i._plugins = {}); if (n.id === this._cacheId) return n.descriptors; var o = [], a = [], s = i && i.config || {}, l = t.defaults.global.plugins, u = s.options && s.options.plugins || {}; return this._plugins.concat(s.plugins || []).forEach(function (t) { if (-1 === o.indexOf(t)) { var i = t.id, n = u[i]; !1 !== n && (!0 === n && (n = e.clone(l[i])), o.push(t), a.push({ plugin: t, options: n || {} })) } }), n.descriptors = a, n.id = this._cacheId, a } }, t.pluginService = t.plugins, t.PluginBase = e.inherits({}) } }, {},], 32: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t, e, i) { return n.isArray(e) ? n.longestText(t, i, e) : t.measureText(e).width } function i(e) { var i = n.getValueOrDefault, o = t.defaults.global, a = i(e.fontSize, o.defaultFontSize), s = i(e.fontStyle, o.defaultFontStyle), l = i(e.fontFamily, o.defaultFontFamily); return { size: a, style: s, family: l, font: n.fontString(a, s, l) } } var n = t.helpers; t.defaults.scale = { display: !0, position: "left", gridLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: "rgba(0,0,0,0.25)", offsetGridLines: !1, borderDash: [], borderDashOffset: 0 }, scaleLabel: { labelString: "", display: !1 }, ticks: { beginAtZero: !1, minRotation: 0, maxRotation: 50, mirror: !1, padding: 0, reverse: !1, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: t.Ticks.formatters.values } }, t.Scale = t.Element.extend({ getPadding: function () { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } }, beforeUpdate: function () { n.callCallback(this.options.beforeUpdate, [this]) }, update: function (t, e, i) { var o = this; return o.beforeUpdate(), o.maxWidth = t, o.maxHeight = e, o.margins = n.extend({ left: 0, right: 0, top: 0, bottom: 0 }, i), o.longestTextCache = o.longestTextCache || {}, o.beforeSetDimensions(), o.setDimensions(), o.afterSetDimensions(), o.beforeDataLimits(), o.determineDataLimits(), o.afterDataLimits(), o.beforeBuildTicks(), o.buildTicks(), o.afterBuildTicks(), o.beforeTickToLabelConversion(), o.convertTicksToLabels(), o.afterTickToLabelConversion(), o.beforeCalculateTickRotation(), o.calculateTickRotation(), o.afterCalculateTickRotation(), o.beforeFit(), o.fit(), o.afterFit(), o.afterUpdate(), o.minSize }, afterUpdate: function () { n.callCallback(this.options.afterUpdate, [this]) }, beforeSetDimensions: function () { n.callCallback(this.options.beforeSetDimensions, [this]) }, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0 }, afterSetDimensions: function () { n.callCallback(this.options.afterSetDimensions, [this]) }, beforeDataLimits: function () { n.callCallback(this.options.beforeDataLimits, [this]) }, determineDataLimits: n.noop, afterDataLimits: function () { n.callCallback(this.options.afterDataLimits, [this]) }, beforeBuildTicks: function () { n.callCallback(this.options.beforeBuildTicks, [this]) }, buildTicks: n.noop, afterBuildTicks: function () { n.callCallback(this.options.afterBuildTicks, [this]) }, beforeTickToLabelConversion: function () { n.callCallback(this.options.beforeTickToLabelConversion, [this,]) }, convertTicksToLabels: function () { var t = this, e = t.options.ticks; t.ticks = t.ticks.map(e.userCallback || e.callback) }, afterTickToLabelConversion: function () { n.callCallback(this.options.afterTickToLabelConversion, [this,]) }, beforeCalculateTickRotation: function () { n.callCallback(this.options.beforeCalculateTickRotation, [this,]) }, calculateTickRotation: function () { var t = this, e = t.ctx, o = t.options.ticks, a = i(o); e.font = a.font; var s = o.minRotation || 0; if (t.options.display && t.isHorizontal()) for (var l, u, c = n.longestText(e, a.font, t.ticks, t.longestTextCache), d = c, h = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; d > h && s < o.maxRotation;) { var f = n.toRadians(s); if (l = Math.cos(f), (u = Math.sin(f)) * c > t.maxHeight) { s--; break } s++, d = l * c } t.labelRotation = s }, afterCalculateTickRotation: function () { n.callCallback(this.options.afterCalculateTickRotation, [this,]) }, beforeFit: function () { n.callCallback(this.options.beforeFit, [this]) }, fit: function () { var t = this, o = t.minSize = { width: 0, height: 0 }, a = t.options, s = a.ticks, l = a.scaleLabel, u = a.gridLines, c = a.display, d = t.isHorizontal(), h = i(s), f = 1.5 * i(l).size, p = a.gridLines.tickMarkLength; if (d ? o.width = t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : o.width = c && u.drawTicks ? p : 0, d ? o.height = c && u.drawTicks ? p : 0 : o.height = t.maxHeight, l.display && c && (d ? o.height += f : o.width += f), s.display && c) { var $ = n.longestText(t.ctx, h.font, t.ticks, t.longestTextCache), m = n.numberOfLabelLines(t.ticks), v = .5 * h.size; if (d) { t.longestLabelWidth = $; var _ = n.toRadians(t.labelRotation), x = Math.cos(_), y = Math.sin(_) * $ + h.size * m + v * m; o.height = Math.min(t.maxHeight, o.height + y), t.ctx.font = h.font; var k = t.ticks[0], S = e(t.ctx, k, h.font), w = t.ticks[t.ticks.length - 1], C = e(t.ctx, w, h.font); 0 !== t.labelRotation ? (t.paddingLeft = "bottom" === a.position ? x * S + 3 : x * v + 3, t.paddingRight = "bottom" === a.position ? x * v + 3 : x * C + 3) : (t.paddingLeft = S / 2 + 3, t.paddingRight = C / 2 + 3) } else s.mirror ? $ = 0 : $ += t.options.ticks.padding, o.width += $, t.paddingTop = h.size / 2, t.paddingBottom = h.size / 2 } t.handleMargins(), t.width = o.width, t.height = o.height }, handleMargins: function () { var t = this; t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0)) }, afterFit: function () { n.callCallback(this.options.afterFit, [this]) }, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position }, isFullWidth: function () { return this.options.fullWidth }, getRightValue: function (t) { return null == t ? NaN : "number" != typeof t || isFinite(t) ? "object" == typeof t ? t instanceof Date || t.isValid ? t : this.getRightValue(this.isHorizontal() ? t.x : t.y) : t : NaN }, getLabelForIndex: n.noop, getPixelForValue: n.noop, getValueForPixel: n.noop, getPixelForTick: function (t, e) { if (this.isHorizontal()) { var i, n = (this.width - (this.paddingLeft + this.paddingRight)) / Math.max(this.ticks.length - (this.options.gridLines.offsetGridLines ? 0 : 1), 1), o = n * t + this.paddingLeft; return e && (o += n / 2), this.left + Math.round(o) + (this.isFullWidth() ? this.margins.left : 0) } var a = this.height - (this.paddingTop + this.paddingBottom); return this.top + t * (a / (this.ticks.length - 1)) }, getPixelForDecimal: function (t) { if (this.isHorizontal()) { var e, i = (this.width - (this.paddingLeft + this.paddingRight)) * t + this.paddingLeft; return this.left + Math.round(i) + (this.isFullWidth() ? this.margins.left : 0) } return this.top + t * this.height }, getBasePixel: function () { return this.getPixelForValue(this.getBaseValue()) }, getBaseValue: function () { var t = this.min, e = this.max; return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 }, draw: function (e) { var o = this, a = o.options; if (a.display) { var s, l, u = o.ctx, c = t.defaults.global, d = a.ticks, h = a.gridLines, f = a.scaleLabel, p = 0 !== o.labelRotation, $ = d.autoSkip, m = o.isHorizontal(); d.maxTicksLimit && (l = d.maxTicksLimit); var v = n.getValueOrDefault(d.fontColor, c.defaultFontColor), _ = i(d), x = h.drawTicks ? h.tickMarkLength : 0, y = n.getValueOrDefault(h.borderDash, c.borderDash), k = n.getValueOrDefault(h.borderDashOffset, c.borderDashOffset), S = n.getValueOrDefault(f.fontColor, c.defaultFontColor), w = i(f), C = n.toRadians(o.labelRotation), D = o.longestLabelWidth * Math.cos(C); u.fillStyle = v; var I = []; if (m) { if (s = !1, p && (D /= 2), (D + d.autoSkipPadding) * o.ticks.length > o.width - (o.paddingLeft + o.paddingRight) && (s = 1 + Math.floor((D + d.autoSkipPadding) * o.ticks.length / (o.width - (o.paddingLeft + o.paddingRight)))), l && o.ticks.length > l) for (; !s || o.ticks.length / (s || 1) > l;)s || (s = 1), s += 1; $ || (s = !1) } var A = "right" === a.position ? o.left : o.right - x, P = "right" === a.position ? o.left + x : o.right, T = "bottom" === a.position ? o.top : o.bottom - x, F = "bottom" === a.position ? o.top + x : o.bottom; if (n.each(o.ticks, function (t, i) { if (null != t) { var l = o.ticks.length === i + 1; if ((!(s > 1 && i % s > 0 || i % s == 0 && i + s >= o.ticks.length) || l) && null != t) { i === (void 0 !== o.zeroLineIndex ? o.zeroLineIndex : 0) ? (u = h.zeroLineWidth, c = h.zeroLineColor) : (u = n.getValueAtIndexOrDefault(h.lineWidth, i), c = n.getValueAtIndexOrDefault(h.color, i)); var u, c, f, $, v, _, S, w, D, V, R, L, O = "middle", B = "middle"; if (m) { "bottom" === a.position ? (B = p ? "middle" : "top", O = p ? "right" : "center", L = o.top + x) : (B = p ? "middle" : "bottom", O = p ? "left" : "center", L = o.bottom - x); var z = o.getPixelForTick(i) + n.aliasPixel(u); R = o.getPixelForTick(i, h.offsetGridLines) + d.labelOffset, f = v = S = D = z, $ = T, _ = F, w = e.top, V = e.bottom } else { var W, M = "left" === a.position, E = d.padding; d.mirror ? (O = M ? "left" : "right", W = E) : (O = M ? "right" : "left", W = x + E), R = M ? o.right - W : o.left + W; var H = o.getPixelForTick(i); H += n.aliasPixel(u), L = o.getPixelForTick(i, h.offsetGridLines), f = A, v = P, S = e.left, D = e.right, $ = _ = w = V = H } I.push({ tx1: f, ty1: $, tx2: v, ty2: _, x1: S, y1: w, x2: D, y2: V, labelX: R, labelY: L, glWidth: u, glColor: c, glBorderDash: y, glBorderDashOffset: k, rotation: -1 * C, label: t, textBaseline: B, textAlign: O }) } } }), n.each(I, function (t) { if (h.display && (u.save(), u.lineWidth = t.glWidth, u.strokeStyle = t.glColor, u.setLineDash && (u.setLineDash(t.glBorderDash), u.lineDashOffset = t.glBorderDashOffset), u.beginPath(), h.drawTicks && (u.moveTo(t.tx1, t.ty1), u.lineTo(t.tx2, t.ty2)), h.drawOnChartArea && (u.moveTo(t.x1, t.y1), u.lineTo(t.x2, t.y2)), u.stroke(), u.restore()), d.display) { u.save(), u.translate(t.labelX, t.labelY), u.rotate(t.rotation), u.font = _.font, u.textBaseline = t.textBaseline, u.textAlign = t.textAlign; var e = t.label; if (n.isArray(e)) for (var i = 0, o = 0; i < e.length; ++i)u.fillText("" + e[i], 0, o), o += 1.5 * _.size; else u.fillText(e, 0, 0); u.restore() } }), f.display) { var V, R, L = 0; if (m) V = o.left + (o.right - o.left) / 2, R = "bottom" === a.position ? o.bottom - w.size / 2 : o.top + w.size / 2; else { var O = "left" === a.position; V = O ? o.left + w.size / 2 : o.right - w.size / 2, R = o.top + (o.bottom - o.top) / 2, L = O ? -.5 * Math.PI : .5 * Math.PI } u.save(), u.translate(V, R), u.rotate(L), u.textAlign = "center", u.textBaseline = "middle", u.fillStyle = S, u.font = w.font, u.fillText(f.labelString, 0, 0), u.restore() } if (h.drawBorder) { u.lineWidth = n.getValueAtIndexOrDefault(h.lineWidth, 0), u.strokeStyle = n.getValueAtIndexOrDefault(h.color, 0); var B = o.left, z = o.right, W = o.top, M = o.bottom, E = n.aliasPixel(u.lineWidth); m ? (W = M = "top" === a.position ? o.bottom : o.top, W += E, M += E) : (B = z = "left" === a.position ? o.right : o.left, B += E, z += E), u.beginPath(), u.moveTo(B, W), u.lineTo(z, M), u.stroke() } } } }) } }, {},], 33: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.scaleService = { constructors: {}, defaults: {}, registerScaleType: function (t, i, n) { this.constructors[t] = i, this.defaults[t] = e.clone(n) }, getScaleConstructor: function (t) { return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0 }, getScaleDefaults: function (i) { return this.defaults.hasOwnProperty(i) ? e.scaleMerge(t.defaults.scale, this.defaults[i]) : {} }, updateScaleDefaults: function (t, i) { var n = this.defaults; n.hasOwnProperty(t) && (n[t] = e.extend(n[t], i)) }, addScalesToLayout: function (i) { e.each(i.scales, function (e) { t.layoutService.addBox(i, e) }) } } } }, {},], 34: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers; t.Ticks = { generators: { linear: function (t, i) { var n, o = []; if (t.stepSize && t.stepSize > 0) n = t.stepSize; else { var a = e.niceNum(i.max - i.min, !1); n = e.niceNum(a / (t.maxTicks - 1), !0) } var s = Math.floor(i.min / n) * n, l = Math.ceil(i.max / n) * n; t.min && t.max && t.stepSize && e.almostWhole((t.max - t.min) / t.stepSize, n / 1e3) && (s = t.min, l = t.max); var u = (l - s) / n; u = e.almostEquals(u, Math.round(u), n / 1e3) ? Math.round(u) : Math.ceil(u), o.push(void 0 !== t.min ? t.min : s); for (var c = 1; c < u; ++c)o.push(s + c * n); return o.push(void 0 !== t.max ? t.max : l), o }, logarithmic: function (t, i) { var n, o, a = [], s = e.getValueOrDefault, l = s(t.min, Math.pow(10, Math.floor(e.log10(i.min)))), u = Math.floor(e.log10(i.max)), c = Math.ceil(i.max / Math.pow(10, u)); 0 === l ? (n = Math.floor(e.log10(i.minNotZero)), o = Math.floor(i.minNotZero / Math.pow(10, n)), a.push(l), l = o * Math.pow(10, n)) : (n = Math.floor(e.log10(l)), o = Math.floor(l / Math.pow(10, n))); do a.push(l), 10 == ++o && (o = 1, ++n), l = o * Math.pow(10, n); while (n < u || n === u && o < c); return a.push(s(t.max, l)), a } }, formatters: { values: function (t) { return e.isArray(t) ? t : "" + t }, linear: function (t, i, n) { var o = n.length > 3 ? n[2] - n[1] : n[1] - n[0]; Math.abs(o) > 1 && t !== Math.floor(t) && (o = t - Math.floor(t)); var a = e.log10(Math.abs(o)), s = ""; if (0 !== t) { var l = -1 * Math.floor(a); l = Math.max(Math.min(l, 20), 0), s = t.toFixed(l) } else s = "0"; return s }, logarithmic: function (t, i, n) { var o = t / Math.pow(10, Math.floor(e.log10(t))); return 0 === t ? "0" : 1 === o || 2 === o || 5 === o || 0 === i || i === n.length - 1 ? t.toExponential() : "" } } } } }, {},], 35: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(e, i) { var n = new t.Title({ ctx: e.chart.ctx, options: i, chart: e }); e.titleBlock = n, t.layoutService.addBox(e, n) } var i = t.helpers; t.defaults.global.title = { display: !1, position: "top", fullWidth: !0, fontStyle: "bold", padding: 10, text: "" }; var n = i.noop; t.Title = t.Element.extend({ initialize: function (t) { var e = this; i.extend(e, t), e.legendHitBoxes = [] }, beforeUpdate: n, update: function (t, e, i) { var n = this; return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize }, afterUpdate: n, beforeSetDimensions: n, setDimensions: function () { var t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = { width: 0, height: 0 } }, afterSetDimensions: n, beforeBuildLabels: n, buildLabels: n, afterBuildLabels: n, beforeFit: n, fit: function () { var e = this, n = i.getValueOrDefault, o = e.options, a = t.defaults.global, s = o.display, l = n(o.fontSize, a.defaultFontSize), u = e.minSize; e.isHorizontal() ? (u.width = e.maxWidth, u.height = s ? l + 2 * o.padding : 0) : (u.width = s ? l + 2 * o.padding : 0, u.height = e.maxHeight), e.width = u.width, e.height = u.height }, afterFit: n, isHorizontal: function () { var t = this.options.position; return "top" === t || "bottom" === t }, draw: function () { var e = this.ctx, n = i.getValueOrDefault, o = this.options, a = t.defaults.global; if (o.display) { var s, l, u, c = n(o.fontSize, a.defaultFontSize), d = n(o.fontStyle, a.defaultFontStyle), h = n(o.fontFamily, a.defaultFontFamily), f = i.fontString(c, d, h), p = 0, $ = this.top, m = this.left, v = this.bottom, _ = this.right; e.fillStyle = n(o.fontColor, a.defaultFontColor), e.font = f, this.isHorizontal() ? (s = m + (_ - m) / 2, l = $ + (v - $) / 2, u = _ - m) : (s = "left" === o.position ? m + c / 2 : _ - c / 2, l = $ + (v - $) / 2, u = v - $, p = Math.PI * ("left" === o.position ? -.5 : .5)), e.save(), e.translate(s, l), e.rotate(p), e.textAlign = "center", e.textBaseline = "middle", e.fillText(o.text, 0, 0, u), e.restore() } } }), t.plugins.register({ beforeInit: function (t) { var i = t.options.title; i && e(t, i) }, beforeUpdate: function (n) { var o = n.options.title; o ? (o = i.configMerge(t.defaults.global.title, o), n.titleBlock ? n.titleBlock.options = o : e(n, o)) : (t.layoutService.removeBox(n, n.titleBlock), delete n.titleBlock) } }) } }, {},], 36: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t, e) { var i = a.color(t); return i.alpha(e * i.alpha()).rgbaString() } function i(t, e) { return e && (a.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function n(t) { var e = t._xScale, i = t._yScale || t._scale, n = t._index, o = t._datasetIndex; return { xLabel: e ? e.getLabelForIndex(n, o) : "", yLabel: i ? i.getLabelForIndex(n, o) : "", index: n, datasetIndex: o, x: t._model.x, y: t._model.y } } function o(e) { var i = t.defaults.global, n = a.getValueOrDefault; return { xPadding: e.xPadding, yPadding: e.yPadding, xAlign: e.xAlign, yAlign: e.yAlign, bodyFontColor: e.bodyFontColor, _bodyFontFamily: n(e.bodyFontFamily, i.defaultFontFamily), _bodyFontStyle: n(e.bodyFontStyle, i.defaultFontStyle), _bodyAlign: e.bodyAlign, bodyFontSize: n(e.bodyFontSize, i.defaultFontSize), bodySpacing: e.bodySpacing, titleFontColor: e.titleFontColor, _titleFontFamily: n(e.titleFontFamily, i.defaultFontFamily), _titleFontStyle: n(e.titleFontStyle, i.defaultFontStyle), titleFontSize: n(e.titleFontSize, i.defaultFontSize), _titleAlign: e.titleAlign, titleSpacing: e.titleSpacing, titleMarginBottom: e.titleMarginBottom, footerFontColor: e.footerFontColor, _footerFontFamily: n(e.footerFontFamily, i.defaultFontFamily), _footerFontStyle: n(e.footerFontStyle, i.defaultFontStyle), footerFontSize: n(e.footerFontSize, i.defaultFontSize), _footerAlign: e.footerAlign, footerSpacing: e.footerSpacing, footerMarginTop: e.footerMarginTop, caretSize: e.caretSize, cornerRadius: e.cornerRadius, backgroundColor: e.backgroundColor, opacity: 0, legendColorBackground: e.multiKeyBackground, displayColors: e.displayColors } } var a = t.helpers; t.defaults.global.tooltips = { enabled: !0, custom: null, mode: "nearest", position: "average", intersect: !0, backgroundColor: "rgba(0,0,0,0.8)", titleFontStyle: "bold", titleSpacing: 2, titleMarginBottom: 6, titleFontColor: "#fff", titleAlign: "left", bodySpacing: 2, bodyFontColor: "#fff", bodyAlign: "left", footerFontStyle: "bold", footerSpacing: 2, footerMarginTop: 6, footerFontColor: "#fff", footerAlign: "left", yPadding: 6, xPadding: 6, caretSize: 5, cornerRadius: 6, multiKeyBackground: "#fff", displayColors: !0, callbacks: { beforeTitle: a.noop, title: function (t, e) { var i = "", n = e.labels, o = n ? n.length : 0; if (t.length > 0) { var a = t[0]; a.xLabel ? i = a.xLabel : o > 0 && a.index < o && (i = n[a.index]) } return i }, afterTitle: a.noop, beforeBody: a.noop, beforeLabel: a.noop, label: function (t, e) { return (e.datasets[t.datasetIndex].label || "") + ": " + t.yLabel }, labelColor: function (t, e) { var i = e.getDatasetMeta(t.datasetIndex).data[t.index]._view; return { borderColor: i.borderColor, backgroundColor: i.backgroundColor } }, afterLabel: a.noop, afterBody: a.noop, beforeFooter: a.noop, footer: a.noop, afterFooter: a.noop } }, t.Tooltip = t.Element.extend({ initialize: function () { this._model = o(this._options) }, getTitle: function () { var t = this._options.callbacks, e = t.beforeTitle.apply(this, arguments), n = t.title.apply(this, arguments), o = t.afterTitle.apply(this, arguments), a = []; return a = i(a, e), a = i(a, n), a = i(a, o) }, getBeforeBody: function () { var t = this._options.callbacks.beforeBody.apply(this, arguments); return a.isArray(t) ? t : void 0 !== t ? [t] : [] }, getBody: function (t, e) { var n = this, o = n._options.callbacks, s = []; return a.each(t, function (t) { var a = { before: [], lines: [], after: [] }; i(a.before, o.beforeLabel.call(n, t, e)), i(a.lines, o.label.call(n, t, e)), i(a.after, o.afterLabel.call(n, t, e)), s.push(a) }), s }, getAfterBody: function () { var t = this._options.callbacks.afterBody.apply(this, arguments); return a.isArray(t) ? t : void 0 !== t ? [t] : [] }, getFooter: function () { var t = this._options.callbacks, e = t.beforeFooter.apply(this, arguments), n = t.footer.apply(this, arguments), o = t.afterFooter.apply(this, arguments), a = []; return a = i(a, e), a = i(a, n), a = i(a, o) }, update: function (e) { var i, s, l = this, u = l._options, c = l._model, d = l._model = o(u), h = l._active, f = l._data, p = l._chartInstance, $ = { xAlign: c.xAlign, yAlign: c.yAlign }, m = { x: c.x, y: c.y }, v = { width: c.width, height: c.height }, _ = { x: c.caretX, y: c.caretY }; if (h.length) { d.opacity = 1; var x, y, k, S, w, C, D, I, A, P, T, F, V, R, L, O, B, z, W, M, E, H, N, U, j, q, Y, X, K, G, J, Z, Q, tt, te, ti, tn, to, ta, tr, ts, tl = []; _ = t.Tooltip.positioners[u.position](h, l._eventPosition); var tu = []; for (i = 0, s = h.length; i < s; ++i)tu.push(n(h[i])); u.filter && (tu = tu.filter(function (t) { return u.filter(t, f) })), u.itemSort && (tu = tu.sort(function (t, e) { return u.itemSort(t, e, f) })), a.each(tu, function (t) { tl.push(u.callbacks.labelColor.call(l, t, p)) }), d.title = l.getTitle(tu, f), d.beforeBody = l.getBeforeBody(tu, f), d.body = l.getBody(tu, f), d.afterBody = l.getAfterBody(tu, f), d.footer = l.getFooter(tu, f), d.x = Math.round(_.x), d.y = Math.round(_.y), d.caretPadding = a.getValueOrDefault(_.padding, 2), d.labelColors = tl, d.dataPoints = tu, v = (x = this, y = d, k = x._chart.ctx, S = 2 * y.yPadding, w = 0, D = (C = y.body).reduce(function (t, e) { return t + e.before.length + e.lines.length + e.after.length }, 0), D += y.beforeBody.length + y.afterBody.length, I = y.title.length, A = y.footer.length, P = y.titleFontSize, T = y.bodyFontSize, F = y.footerFontSize, S += I * P, S += I ? (I - 1) * y.titleSpacing : 0, S += I ? y.titleMarginBottom : 0, S += D * T, S += D ? (D - 1) * y.bodySpacing : 0, S += A ? y.footerMarginTop : 0, S += A * F, S += A ? (A - 1) * y.footerSpacing : 0, V = 0, R = function (t) { w = Math.max(w, k.measureText(t).width + V) }, k.font = a.fontString(P, y._titleFontStyle, y._titleFontFamily), a.each(y.title, R), k.font = a.fontString(T, y._bodyFontStyle, y._bodyFontFamily), a.each(y.beforeBody.concat(y.afterBody), R), V = y.displayColors ? T + 2 : 0, a.each(C, function (t) { a.each(t.before, R), a.each(t.lines, R), a.each(t.after, R) }), V = 0, k.font = a.fontString(F, y._footerFontStyle, y._footerFontFamily), a.each(y.footer, R), { width: w += 2 * y.xPadding, height: S }), $ = (L = this, O = v, B = L._model, z = L._chart, W = L._chartInstance.chartArea, M = "center", E = "center", B.y < O.height ? E = "top" : B.y > z.height - O.height && (E = "bottom"), Y = (W.left + W.right) / 2, X = (W.top + W.bottom) / 2, "center" === E ? (H = function (t) { return t <= Y }, N = function (t) { return t > Y }) : (H = function (t) { return t <= O.width / 2 }, N = function (t) { return t >= z.width - O.width / 2 }), U = function (t) { return t + O.width > z.width }, j = function (t) { return t - O.width < 0 }, q = function (t) { return t <= X ? "top" : "bottom" }, H(B.x) ? (M = "left", U(B.x) && (M = "center", E = q(B.y))) : N(B.x) && (M = "right", j(B.x) && (M = "center", E = q(B.y))), { xAlign: (K = L._options).xAlign ? K.xAlign : M, yAlign: K.yAlign ? K.yAlign : E }), m = (G = d, J = v, Z = $, Q = G.x, tt = G.y, te = G.caretSize, ti = G.caretPadding, tn = G.cornerRadius, to = Z.xAlign, ta = Z.yAlign, tr = te + ti, ts = tn + ti, "right" === to ? Q -= J.width : "center" === to && (Q -= J.width / 2), "top" === ta ? tt += tr : tt -= "bottom" === ta ? J.height + tr : J.height / 2, "center" === ta ? "left" === to ? Q += tr : "right" === to && (Q -= tr) : "left" === to ? Q -= ts : "right" === to && (Q += ts), { x: Q, y: tt }) } else d.opacity = 0; return d.xAlign = $.xAlign, d.yAlign = $.yAlign, d.x = m.x, d.y = m.y, d.width = v.width, d.height = v.height, d.caretX = _.x, d.caretY = _.y, l._model = d, e && u.custom && u.custom.call(l, d), l }, drawCaret: function (t, i, n) { var o, a, s, l, u, c, d = this._view, h = this._chart.ctx, f = d.caretSize, p = d.cornerRadius, $ = d.xAlign, m = d.yAlign, v = t.x, _ = t.y, x = i.width, y = i.height; "center" === m ? ("left" === $ ? (a = (o = v) - f, s = o) : (a = (o = v + x) + f, s = o), l = (u = _ + y / 2) - f, c = u + f) : ("left" === $ ? s = (a = (o = v + p) + f) + f : "right" === $ ? s = (a = (o = v + x - p) - f) - f : (o = (a = v + x / 2) - f, s = a + f), "top" === m ? (u = (l = _) - f, c = l) : (u = (l = _ + y) + f, c = l)), h.fillStyle = e(d.backgroundColor, n), h.beginPath(), h.moveTo(o, l), h.lineTo(a, u), h.lineTo(s, c), h.closePath(), h.fill() }, drawTitle: function (t, i, n, o) { var s = i.title; if (s.length) { n.textAlign = i._titleAlign, n.textBaseline = "top"; var l, u, c = i.titleFontSize, d = i.titleSpacing; for (n.fillStyle = e(i.titleFontColor, o), n.font = a.fontString(c, i._titleFontStyle, i._titleFontFamily), l = 0, u = s.length; l < u; ++l)n.fillText(s[l], t.x, t.y), t.y += c + d, l + 1 === s.length && (t.y += i.titleMarginBottom - d) } }, drawBody: function (t, i, n, o) { var s = i.bodyFontSize, l = i.bodySpacing, u = i.body; n.textAlign = i._bodyAlign, n.textBaseline = "top"; var c = e(i.bodyFontColor, o); n.fillStyle = c, n.font = a.fontString(s, i._bodyFontStyle, i._bodyFontFamily); var d = 0, h = function (e) { n.fillText(e, t.x + d, t.y), t.y += s + l }; a.each(i.beforeBody, h); var f = i.displayColors; d = f ? s + 2 : 0, a.each(u, function (l, u) { a.each(l.before, h), a.each(l.lines, function (a) { f && (n.fillStyle = e(i.legendColorBackground, o), n.fillRect(t.x, t.y, s, s), n.strokeStyle = e(i.labelColors[u].borderColor, o), n.strokeRect(t.x, t.y, s, s), n.fillStyle = e(i.labelColors[u].backgroundColor, o), n.fillRect(t.x + 1, t.y + 1, s - 2, s - 2), n.fillStyle = c), h(a) }), a.each(l.after, h) }), d = 0, a.each(i.afterBody, h), t.y -= l }, drawFooter: function (t, i, n, o) { var s = i.footer; s.length && (t.y += i.footerMarginTop, n.textAlign = i._footerAlign, n.textBaseline = "top", n.fillStyle = e(i.footerFontColor, o), n.font = a.fontString(i.footerFontSize, i._footerFontStyle, i._footerFontFamily), a.each(s, function (e) { n.fillText(e, t.x, t.y), t.y += i.footerFontSize + i.footerSpacing })) }, drawBackground: function (t, i, n, o, s) { n.fillStyle = e(i.backgroundColor, s), a.drawRoundedRectangle(n, t.x, t.y, o.width, o.height, i.cornerRadius), n.fill() }, draw: function () { var t = this._chart.ctx, e = this._view; if (0 !== e.opacity) { var i = { width: e.width, height: e.height }, n = { x: e.x, y: e.y }, o = Math.abs(e.opacity < .001) ? 0 : e.opacity; this._options.enabled && (this.drawBackground(n, e, t, i, o), this.drawCaret(n, i, o), n.x += e.xPadding, n.y += e.yPadding, this.drawTitle(n, e, t, o), this.drawBody(n, e, t, o), this.drawFooter(n, e, t, o)) } }, handleEvent: function (t) { var e = this, i = e._options, n = !1; if (e._lastActive = e._lastActive || [], "mouseout" === t.type ? e._active = [] : e._active = e._chartInstance.getElementsAtEventForMode(t, i.mode, i), n = !a.arrayEquals(e._active, e._lastActive), e._lastActive = e._active, i.enabled || i.custom) { e._eventPosition = { x: t.x, y: t.y }; var o = e._model; e.update(!0), e.pivot(), n |= o.x !== e._model.x || o.y !== e._model.y } return n } }), t.Tooltip.positioners = { average: function (t) { if (!t.length) return !1; var e, i, n = 0, o = 0, a = 0; for (e = 0, i = t.length; e < i; ++e) { var s = t[e]; if (s && s.hasValue()) { var l = s.tooltipPosition(); n += l.x, o += l.y, ++a } } return { x: Math.round(n / a), y: Math.round(o / a) } }, nearest: function (t, e) { var i, n, o, s = e.x, l = e.y, u = Number.POSITIVE_INFINITY; for (n = 0, o = t.length; n < o; ++n) { var c = t[n]; if (c && c.hasValue()) { var d = c.getCenterPoint(), h = a.distanceBetweenPoints(e, d); h < u && (u = h, i = c) } } if (i) { var f = i.tooltipPosition(); s = f.x, l = f.y } return { x: s, y: l } } } } }, {},], 37: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers, i = t.defaults.global; i.elements.arc = { backgroundColor: i.defaultColor, borderColor: "#fff", borderWidth: 2 }, t.elements.Arc = t.Element.extend({ inLabelRange: function (t) { var e = this._view; return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2) }, inRange: function (t, i) { var n = this._view; if (n) { for (var o = e.getAngleFromPoint(n, { x: t, y: i }), a = o.angle, s = o.distance, l = n.startAngle, u = n.endAngle; u < l;)u += 2 * Math.PI; for (; a > u;)a -= 2 * Math.PI; for (; a < l;)a += 2 * Math.PI; var c = a >= l && a <= u, d = s >= n.innerRadius && s <= n.outerRadius; return c && d } return !1 }, getCenterPoint: function () { var t = this._view, e = (t.startAngle + t.endAngle) / 2, i = (t.innerRadius + t.outerRadius) / 2; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i } }, getArea: function () { var t = this._view; return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2)) }, tooltipPosition: function () { var t = this._view, e = t.startAngle + (t.endAngle - t.startAngle) / 2, i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i } }, draw: function () { var t = this._chart.ctx, e = this._view, i = e.startAngle, n = e.endAngle; t.beginPath(), t.arc(e.x, e.y, e.outerRadius, i, n), t.arc(e.x, e.y, e.innerRadius, n, i, !0), t.closePath(), t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, t.fill(), t.lineJoin = "bevel", e.borderWidth && t.stroke() } }) } }, {},], 38: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers, i = t.defaults.global; t.defaults.global.elements.line = { tension: .4, backgroundColor: i.defaultColor, borderWidth: 3, borderColor: i.defaultColor, borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", capBezierPoints: !0, fill: !0 }, t.elements.Line = t.Element.extend({ draw: function () { function t(t, e) { var i = e._view; !0 === e._view.steppedLine ? (h.lineTo(i.x, t._view.y), h.lineTo(i.x, i.y)) : 0 === e._view.tension ? h.lineTo(i.x, i.y) : h.bezierCurveTo(t._view.controlPointNextX, t._view.controlPointNextY, i.controlPointPreviousX, i.controlPointPreviousY, i.x, i.y) } var n, o, a, s, l = this._view, u = l.spanGaps, c = l.scaleZero, d = this._loop; d || ("top" === l.fill ? c = l.scaleTop : "bottom" === l.fill && (c = l.scaleBottom)); var h = this._chart.ctx; h.save(); var f = this._children.slice(), p = -1; if (d && f.length && f.push(f[0]), f.length && l.fill) { for (h.beginPath(), n = 0; n < f.length; ++n)o = f[n], a = e.previousItem(f, n), s = o._view, 0 === n ? (d ? h.moveTo(c.x, c.y) : h.moveTo(s.x, c), s.skip || (p = n, h.lineTo(s.x, s.y))) : (a = -1 === p ? a : f[p], s.skip ? u || p !== n - 1 || (d ? h.lineTo(c.x, c.y) : h.lineTo(a._view.x, c)) : (p !== n - 1 ? u && -1 !== p ? t(a, o) : (d || h.lineTo(s.x, c), h.lineTo(s.x, s.y)) : t(a, o), p = n)); d || -1 === p || h.lineTo(f[p]._view.x, c), h.fillStyle = l.backgroundColor || i.defaultColor, h.closePath(), h.fill() } var $ = i.elements.line; for (h.lineCap = l.borderCapStyle || $.borderCapStyle, h.setLineDash && h.setLineDash(l.borderDash || $.borderDash), h.lineDashOffset = l.borderDashOffset || $.borderDashOffset, h.lineJoin = l.borderJoinStyle || $.borderJoinStyle, h.lineWidth = l.borderWidth || $.borderWidth, h.strokeStyle = l.borderColor || i.defaultColor, h.beginPath(), p = -1, n = 0; n < f.length; ++n)o = f[n], a = e.previousItem(f, n), s = o._view, 0 === n ? s.skip || (h.moveTo(s.x, s.y), p = n) : (a = -1 === p ? a : f[p], s.skip || ((p === n - 1 || u) && -1 !== p ? t(a, o) : h.moveTo(s.x, s.y), p = n)); h.stroke(), h.restore() } }) } }, {},], 39: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t) { var e = this._view; return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hitRadius, 2) } var i = t.helpers, n = t.defaults.global, o = n.defaultColor; n.elements.point = { radius: 3, pointStyle: "circle", backgroundColor: o, borderWidth: 1, borderColor: o, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1 }, t.elements.Point = t.Element.extend({ inRange: function (t, e) { var i = this._view; return !!i && Math.pow(t - i.x, 2) + Math.pow(e - i.y, 2) < Math.pow(i.hitRadius + i.radius, 2) }, inLabelRange: e, inXRange: e, inYRange: function t(e) { var i = this._view; return !!i && Math.pow(e - i.y, 2) < Math.pow(i.radius + i.hitRadius, 2) }, getCenterPoint: function () { var t = this._view; return { x: t.x, y: t.y } }, getArea: function () { return Math.PI * Math.pow(this._view.radius, 2) }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y, padding: t.radius + t.borderWidth } }, draw: function (e) { var a = this._view, s = this._model, l = this._chart.ctx, u = a.pointStyle, c = a.radius, d = a.x, h = a.y, f = t.helpers.color, p = 0; a.skip || (l.strokeStyle = a.borderColor || o, l.lineWidth = i.getValueOrDefault(a.borderWidth, n.elements.point.borderWidth), l.fillStyle = a.backgroundColor || o, void 0 !== e && (s.x < e.left || 1.01 * e.right < s.x || s.y < e.top || 1.01 * e.bottom < s.y) && (s.x < e.left ? p = (d - s.x) / (e.left - s.x) : 1.01 * e.right < s.x ? p = (s.x - d) / (s.x - e.right) : s.y < e.top ? p = (h - s.y) / (e.top - s.y) : 1.01 * e.bottom < s.y && (p = (s.y - h) / (s.y - e.bottom)), p = Math.round(100 * p) / 100, l.strokeStyle = f(l.strokeStyle).alpha(p).rgbString(), l.fillStyle = f(l.fillStyle).alpha(p).rgbString()), t.canvasHelpers.drawPoint(l, u, c, d, h)) } }) } }, {},], 40: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t) { return void 0 !== t._view.width } function i(t) { var i, n, o, a, s = t._view; if (e(t)) { var l = s.width / 2; i = s.x - l, n = s.x + l, o = Math.min(s.y, s.base), a = Math.max(s.y, s.base) } else { var u = s.height / 2; i = Math.min(s.x, s.base), n = Math.max(s.x, s.base), o = s.y - u, a = s.y + u } return { left: i, top: o, right: n, bottom: a } } var n = t.defaults.global; n.elements.rectangle = { backgroundColor: n.defaultColor, borderWidth: 0, borderColor: n.defaultColor, borderSkipped: "bottom" }, t.elements.Rectangle = t.Element.extend({ draw: function () { function t(t) { return _[(x + t) % 4] } var e, i, n, o, a, s, l, u = this._chart.ctx, c = this._view, d = c.borderWidth; if (c.horizontal ? (e = c.base, i = c.x, n = c.y - c.height / 2, o = c.y + c.height / 2, a = i > e ? 1 : -1, s = 1, l = c.borderSkipped || "left") : (e = c.x - c.width / 2, i = c.x + c.width / 2, n = c.y, o = c.base, a = 1, s = o > n ? 1 : -1, l = c.borderSkipped || "bottom"), d) { var h = Math.min(Math.abs(e - i), Math.abs(n - o)), f = (d = d > h ? h : d) / 2, p = e + ("left" !== l ? f * a : 0), $ = i + ("right" !== l ? -f * a : 0), m = n + ("top" !== l ? f * s : 0), v = o + ("bottom" !== l ? -f * s : 0); p !== $ && (n = m, o = v), m !== v && (e = p, i = $) } u.beginPath(), u.fillStyle = c.backgroundColor, u.strokeStyle = c.borderColor, u.lineWidth = d; var _ = [[e, o], [e, n], [i, n], [i, o],], x = ["bottom", "left", "top", "right"].indexOf(l, 0); -1 === x && (x = 0); var y = t(0); u.moveTo(y[0], y[1]); for (var k = 1; k < 4; k++)y = t(k), u.lineTo(y[0], y[1]); u.fill(), d && u.stroke() }, height: function () { var t = this._view; return t.base - t.y }, inRange: function (t, e) { var n = !1; if (this._view) { var o = i(this); n = t >= o.left && t <= o.right && e >= o.top && e <= o.bottom } return n }, inLabelRange: function (t, n) { if (!this._view) return !1; var o = i(this); return e(this) ? t >= o.left && t <= o.right : n >= o.top && n <= o.bottom }, inXRange: function (t) { var e = i(this); return t >= e.left && t <= e.right }, inYRange: function (t) { var e = i(this); return t >= e.top && t <= e.bottom }, getCenterPoint: function () { var t, i, n = this._view; return e(this) ? (t = n.x, i = (n.y + n.base) / 2) : (t = (n.x + n.base) / 2, i = n.y), { x: t, y: i } }, getArea: function () { var t = this._view; return t.width * Math.abs(t.y - t.base) }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y } } }) } }, {},], 41: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t, e) { var i = n.getStyle(t, e), o = i && i.match(/(\d+)px/); return o ? Number(o[1]) : void 0 } function i(t, e, i, n, o) { return { type: t, chart: e, native: o || null, x: void 0 !== i ? i : null, y: void 0 !== n ? n : null } } var n = t.helpers, o = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }; return { acquireContext: function (t, i) { if ("string" == typeof t ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t instanceof HTMLCanvasElement) { var n = t.getContext && t.getContext("2d"); if (n instanceof CanvasRenderingContext2D) return function t(i, n) { var o = i.style, a = i.getAttribute("height"), s = i.getAttribute("width"); if (i._chartjs = { initial: { height: a, width: s, style: { display: o.display, height: o.height, width: o.width } } }, o.display = o.display || "block", null === s || "" === s) { var l = e(i, "width"); void 0 !== l && (i.width = l) } if (null === a || "" === a) { if ("" === i.style.height) i.height = i.width / (n.options.aspectRatio || 2); else { var u = e(i, "height"); void 0 !== l && (i.height = u) } } return i }(t, i), n } return null }, releaseContext: function (t) { var e = t.canvas; if (e._chartjs) { var i = e._chartjs.initial;["height", "width"].forEach(function (t) { var n = i[t]; null == n ? e.removeAttribute(t) : e.setAttribute(t, n) }), n.each(i.style || {}, function (t, i) { e.style[i] = t }), e.width = e.width, delete e._chartjs } }, addEventListener: function (t, e, a) { var s = t.chart.canvas; if ("resize" === e) return void (l = s.parentNode, u = a, c = t.chart, d = l._chartjs = { ticking: !1 }, h = function () { d.ticking || (d.ticking = !0, n.requestAnimFrame.call(window, function () { if (d.resizer) return d.ticking = !1, u(i("resize", c)) })) }, void (d.resizer = (f = h, (p = document.createElement("iframe")).className = "chartjs-hidden-iframe", p.style.cssText = "display:block;overflow:hidden;border:0;margin:0;top:0;left:0;bottom:0;right:0;height:100%;width:100%;position:absolute;pointer-events:none;z-index:-1;", p.tabIndex = 1, p.title = "Gr\xe1fico", n.addEvent(p, "load", function () { n.addEvent(p.contentWindow || p, "resize", f), f() }), p), l.insertBefore(d.resizer, l.firstChild))); var l, u, c, d, h, f, p, $ = a._chartjs || (a._chartjs = {}), m = ($.proxies || ($.proxies = {}))[t.id + "_" + e] = function (e) { var s, l, u, c; a((s = e, l = t.chart, u = o[s.type] || s.type, c = n.getRelativePosition(s, l), i(u, l, c.x, c.y, s))) }; n.addEvent(s, e, m) }, removeEventListener: function (t, e, i) { var o = t.chart.canvas; if ("resize" === e) return void function t(e) { if (e && e._chartjs) { var i = e._chartjs.resizer; i && (i.parentNode.removeChild(i), e._chartjs.resizer = null), delete e._chartjs } }(o.parentNode, i); var a = ((i._chartjs || {}).proxies || {})[t.id + "_" + e]; a && n.removeEvent(o, e, a) } } } }, {},], 42: [function (t, e, i) { "use strict"; var n = t(41); e.exports = function (t) { t.platform = { acquireContext: function () { }, releaseContext: function () { }, addEventListener: function () { }, removeEventListener: function () { } }, t.helpers.extend(t.platform, n(t)) } }, { 41: 41 },], 43: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers, i = t.Scale.extend({ getLabels: function () { var t = this.chart.data; return (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels }, determineDataLimits: function () { var t, i = this, n = i.getLabels(); i.minIndex = 0, i.maxIndex = n.length - 1, void 0 !== i.options.ticks.min && (t = e.indexOf(n, i.options.ticks.min), i.minIndex = -1 !== t ? t : i.minIndex), void 0 !== i.options.ticks.max && (t = e.indexOf(n, i.options.ticks.max), i.maxIndex = -1 !== t ? t : i.maxIndex), i.min = n[i.minIndex], i.max = n[i.maxIndex] }, buildTicks: function () { var t = this, e = t.getLabels(); t.ticks = 0 === t.minIndex && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1) }, getLabelForIndex: function (t, e) { var i = this.chart.data, n = this.isHorizontal(); return i.yLabels && !n ? this.getRightValue(i.datasets[e].data[t]) : this.ticks[t - this.minIndex] }, getPixelForValue: function (t, e, i, n) { var o = Math.max(this.maxIndex + 1 - this.minIndex - (this.options.gridLines.offsetGridLines ? 0 : 1), 1); if (void 0 !== t && isNaN(e)) { var a = this.getLabels().indexOf(t); e = -1 !== a ? a : e } if (this.isHorizontal()) { var s = this.width / o, l = s * (e - this.minIndex); return (this.options.gridLines.offsetGridLines && n || this.maxIndex === this.minIndex && n) && (l += s / 2), this.left + Math.round(l) } var u = this.height / o, c = u * (e - this.minIndex); return this.options.gridLines.offsetGridLines && n && (c += u / 2), this.top + Math.round(c) }, getPixelForTick: function (t, e) { return this.getPixelForValue(this.ticks[t], t + this.minIndex, null, e) }, getValueForPixel: function (t) { var e, i = Math.max(this.ticks.length - (this.options.gridLines.offsetGridLines ? 0 : 1), 1), n = this.isHorizontal(), o = (n ? this.width : this.height) / i; return t -= n ? this.left : this.top, this.options.gridLines.offsetGridLines && (t -= o / 2), e = t <= 0 ? 0 : Math.round(t / o) }, getBasePixel: function () { return this.bottom } }); t.scaleService.registerScaleType("category", i, { position: "bottom" }) } }, {},], 44: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers, i = { position: "left", ticks: { callback: t.Ticks.formatters.linear } }, n = t.LinearScaleBase.extend({ determineDataLimits: function () { function t(t) { return s ? t.xAxisID === i.id : t.yAxisID === i.id } var i = this, n = i.options, o = i.chart, a = o.data.datasets, s = i.isHorizontal(); i.min = null, i.max = null; var l = n.stacked; if (void 0 === l && e.each(a, function (e, i) { if (!l) { var n = o.getDatasetMeta(i); o.isDatasetVisible(i) && t(n) && void 0 !== n.stack && (l = !0) } }), n.stacked || l) { var u = {}; e.each(a, function (a, s) { var l = o.getDatasetMeta(s), c = [l.type, void 0 === n.stacked && void 0 === l.stack ? s : "", l.stack,].join("."); void 0 === u[c] && (u[c] = { positiveValues: [], negativeValues: [] }); var d = u[c].positiveValues, h = u[c].negativeValues; o.isDatasetVisible(s) && t(l) && e.each(a.data, function (t, e) { var o = +i.getRightValue(t); isNaN(o) || l.data[e].hidden || (d[e] = d[e] || 0, h[e] = h[e] || 0, n.relativePoints ? d[e] = 100 : o < 0 ? h[e] += o : d[e] += o) }) }), e.each(u, function (t) { var n = t.positiveValues.concat(t.negativeValues), o = e.min(n), a = e.max(n); i.min = null === i.min ? o : Math.min(i.min, o), i.max = null === i.max ? a : Math.max(i.max, a) }) } else e.each(a, function (n, a) { var s = o.getDatasetMeta(a); o.isDatasetVisible(a) && t(s) && e.each(n.data, function (t, e) { var n = +i.getRightValue(t); isNaN(n) || s.data[e].hidden || (null === i.min ? i.min = n : n < i.min && (i.min = n), null === i.max ? i.max = n : n > i.max && (i.max = n)) }) }); this.handleTickRangeOptions() }, getTickLimit: function () { var i, n = this.options.ticks; if (this.isHorizontal()) i = Math.min(n.maxTicksLimit ? n.maxTicksLimit : 11, Math.ceil(this.width / 50)); else { var o = e.getValueOrDefault(n.fontSize, t.defaults.global.defaultFontSize); i = Math.min(n.maxTicksLimit ? n.maxTicksLimit : 11, Math.ceil(this.height / (2 * o))) } return i }, handleDirectionalChanges: function () { this.isHorizontal() || this.ticks.reverse() }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, getPixelForValue: function (t) { var e, i = this.start, n = +this.getRightValue(t), o = this.end - i; return this.isHorizontal() ? Math.round(e = this.left + this.width / o * (n - i)) : Math.round(e = this.bottom - this.height / o * (n - i)) }, getValueForPixel: function (t) { var e = this.isHorizontal(), i = e ? this.width : this.height, n = (e ? t - this.left : this.bottom - t) / i; return this.start + (this.end - this.start) * n }, getPixelForTick: function (t) { return this.getPixelForValue(this.ticksAsNumbers[t]) } }); t.scaleService.registerScaleType("linear", n, i) } }, {},], 45: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers, i = e.noop; t.LinearScaleBase = t.Scale.extend({ handleTickRangeOptions: function () { var t = this, i = t.options.ticks; if (i.beginAtZero) { var n = e.sign(t.min), o = e.sign(t.max); n < 0 && o < 0 ? t.max = 0 : n > 0 && o > 0 && (t.min = 0) } void 0 !== i.min ? t.min = i.min : void 0 !== i.suggestedMin && (t.min = Math.min(t.min, i.suggestedMin)), void 0 !== i.max ? t.max = i.max : void 0 !== i.suggestedMax && (t.max = Math.max(t.max, i.suggestedMax)), t.min === t.max && (t.max++, i.beginAtZero || t.min--) }, getTickLimit: i, handleDirectionalChanges: i, buildTicks: function () { var i = this, n = i.options.ticks, o = i.getTickLimit(), a = { maxTicks: o = Math.max(2, o), min: n.min, max: n.max, stepSize: e.getValueOrDefault(n.fixedStepSize, n.stepSize) }, s = i.ticks = t.Ticks.generators.linear(a, i); i.handleDirectionalChanges(), i.max = e.max(s), i.min = e.min(s), n.reverse ? (s.reverse(), i.start = i.max, i.end = i.min) : (i.start = i.min, i.end = i.max) }, convertTicksToLabels: function () { var e = this; e.ticksAsNumbers = e.ticks.slice(), e.zeroLineIndex = e.ticks.indexOf(0), t.Scale.prototype.convertTicksToLabels.call(e) } }) } }, {},], 46: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.helpers, i = { position: "left", ticks: { callback: t.Ticks.formatters.logarithmic } }, n = t.Scale.extend({ determineDataLimits: function () { function t(t) { return u ? t.xAxisID === i.id : t.yAxisID === i.id } var i = this, n = i.options, o = n.ticks, a = i.chart, s = a.data.datasets, l = e.getValueOrDefault, u = i.isHorizontal(); i.min = null, i.max = null, i.minNotZero = null; var c = n.stacked; if (void 0 === c && e.each(s, function (e, i) { if (!c) { var n = a.getDatasetMeta(i); a.isDatasetVisible(i) && t(n) && void 0 !== n.stack && (c = !0) } }), n.stacked || c) { var d = {}; e.each(s, function (o, s) { var l = a.getDatasetMeta(s), u = [l.type, void 0 === n.stacked && void 0 === l.stack ? s : "", l.stack,].join("."); a.isDatasetVisible(s) && t(l) && (void 0 === d[u] && (d[u] = []), e.each(o.data, function (t, e) { var o = d[u], a = +i.getRightValue(t); isNaN(a) || l.data[e].hidden || (o[e] = o[e] || 0, n.relativePoints ? o[e] = 100 : o[e] += a) })) }), e.each(d, function (t) { var n = e.min(t), o = e.max(t); i.min = null === i.min ? n : Math.min(i.min, n), i.max = null === i.max ? o : Math.max(i.max, o) }) } else e.each(s, function (n, o) { var s = a.getDatasetMeta(o); a.isDatasetVisible(o) && t(s) && e.each(n.data, function (t, e) { var n = +i.getRightValue(t); isNaN(n) || s.data[e].hidden || (null === i.min ? i.min = n : n < i.min && (i.min = n), null === i.max ? i.max = n : n > i.max && (i.max = n), 0 !== n && (null === i.minNotZero || n < i.minNotZero) && (i.minNotZero = n)) }) }); i.min = l(o.min, i.min), i.max = l(o.max, i.max), i.min === i.max && (0 !== i.min && null !== i.min ? (i.min = Math.pow(10, Math.floor(e.log10(i.min)) - 1), i.max = Math.pow(10, Math.floor(e.log10(i.max)) + 1)) : (i.min = 1, i.max = 10)) }, buildTicks: function () { var i = this, n = i.options.ticks, o = { min: n.min, max: n.max }, a = i.ticks = t.Ticks.generators.logarithmic(o, i); i.isHorizontal() || a.reverse(), i.max = e.max(a), i.min = e.min(a), n.reverse ? (a.reverse(), i.start = i.max, i.end = i.min) : (i.start = i.min, i.end = i.max) }, convertTicksToLabels: function () { this.tickValues = this.ticks.slice(), t.Scale.prototype.convertTicksToLabels.call(this) }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, getPixelForTick: function (t) { return this.getPixelForValue(this.tickValues[t]) }, getPixelForValue: function (t) { var i, n, o, a = this.start, s = +this.getRightValue(t), l = this.options.ticks; return this.isHorizontal() ? (o = e.log10(this.end) - e.log10(a), 0 === s ? n = this.left : (i = this.width, n = this.left + i / o * (e.log10(s) - e.log10(a)))) : (i = this.height, 0 !== a || l.reverse ? 0 === this.end && l.reverse ? (o = e.log10(this.start) - e.log10(this.minNotZero), n = s === this.end ? this.top : s === this.minNotZero ? this.top + .02 * i : this.top + .02 * i + .98 * i / o * (e.log10(s) - e.log10(this.minNotZero))) : (o = e.log10(this.end) - e.log10(a), i = this.height, n = this.bottom - i / o * (e.log10(s) - e.log10(a))) : (o = e.log10(this.end) - e.log10(this.minNotZero), n = s === a ? this.bottom : s === this.minNotZero ? this.bottom - .02 * i : this.bottom - .02 * i - .98 * i / o * (e.log10(s) - e.log10(this.minNotZero)))), n }, getValueForPixel: function (t) { var i, n, o = e.log10(this.end) - e.log10(this.start); return this.isHorizontal() ? (n = this.width, i = this.start * Math.pow(10, (t - this.left) * o / n)) : (n = this.height, i = Math.pow(10, (this.bottom - t) * o / n) / this.start), i } }); t.scaleService.registerScaleType("logarithmic", n, i) } }, {},], 47: [function (t, e, i) { "use strict"; e.exports = function (t) { function e(t) { return t.options.lineArc ? 0 : t.chart.data.labels.length } function i(t) { var e = t.options.pointLabels, i = c.getValueOrDefault(e.fontSize, d.defaultFontSize), n = c.getValueOrDefault(e.fontStyle, d.defaultFontStyle), o = c.getValueOrDefault(e.fontFamily, d.defaultFontFamily), a = c.fontString(i, n, o); return { size: i, style: n, family: o, font: a } } function n(t, e, i) { return c.isArray(i) ? { w: c.longestText(t, t.font, i), h: i.length * e + 1.5 * (i.length - 1) * e } : { w: t.measureText(i).width, h: e } } function o(t, e, i, n, o) { return t === n || t === o ? { start: e - i / 2, end: e + i / 2 } : t < n || t > o ? { start: e - i - 5, end: e } : { start: e, end: e + i + 5 } } function a(t) { return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right" } function s(t, e, i, n) { if (c.isArray(e)) for (var o = i.y, a = 1.5 * n, s = 0; s < e.length; ++s)t.fillText(e[s], i.x, o), o += a; else t.fillText(e, i.x, i.y) } function l(t, e, i) { 90 === t || 270 === t ? i.y -= e.h / 2 : (t > 270 || t < 90) && (i.y -= e.h) } function u(t) { return c.isNumber(t) ? t : 0 } var c = t.helpers, d = t.defaults.global, h = { display: !0, animate: !0, lineArc: !1, position: "chartArea", angleLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1 }, ticks: { showLabelBackdrop: !0, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2, callback: t.Ticks.formatters.linear }, pointLabels: { fontSize: 10, callback: function (t) { return t } } }, f = t.LinearScaleBase.extend({ setDimensions: function () { var t = this, e = t.options, i = e.ticks; t.width = t.maxWidth, t.height = t.maxHeight, t.xCenter = Math.round(t.width / 2), t.yCenter = Math.round(t.height / 2); var n = c.min([t.height, t.width]), o = c.getValueOrDefault(i.fontSize, d.defaultFontSize); t.drawingArea = e.display ? n / 2 - (o / 2 + i.backdropPaddingY) : n / 2 }, determineDataLimits: function () { var t = this, e = t.chart, i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY; c.each(e.data.datasets, function (o, a) { if (e.isDatasetVisible(a)) { var s = e.getDatasetMeta(a); c.each(o.data, function (e, o) { var a = +t.getRightValue(e); isNaN(a) || s.data[o].hidden || (i = Math.min(a, i), n = Math.max(a, n)) }) } }), t.min = i === Number.POSITIVE_INFINITY ? 0 : i, t.max = n === Number.NEGATIVE_INFINITY ? 0 : n, t.handleTickRangeOptions() }, getTickLimit: function () { var t = this.options.ticks, e = c.getValueOrDefault(t.fontSize, d.defaultFontSize); return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * e))) }, convertTicksToLabels: function () { var e = this; t.LinearScaleBase.prototype.convertTicksToLabels.call(e), e.pointLabels = e.chart.data.labels.map(e.options.pointLabels.callback, e) }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, fit: function () { var t, a; this.options.lineArc ? (t = this, a = Math.min(t.height / 2, t.width / 2), t.drawingArea = Math.round(a), t.setCenterPoint(0, 0, 0, 0)) : function t(a) { var s, l, u, d = i(a), h = Math.min(a.height / 2, a.width / 2), f = { l: a.width, r: 0, t: a.height, b: 0 }, p = {}; a.ctx.font = d.font, a._pointLabelSizes = []; var $ = e(a); for (s = 0; s < $; s++) { u = a.getPointPosition(s, h), l = n(a.ctx, d.size, a.pointLabels[s] || ""), a._pointLabelSizes[s] = l; var m = a.getIndexAngle(s), v = c.toDegrees(m) % 360, _ = o(v, u.x, l.w, 0, 180), x = o(v, u.y, l.h, 90, 270); _.start < f.l && (f.l = _.start, p.l = m), _.end > f.r && (f.r = _.end, p.r = m), x.start < f.t && (f.t = x.start, p.t = m), x.end > f.b && (f.b = x.end, p.b = m) } a.setReductions(h, f, p) }(this) }, setReductions: function (t, e, i) { var n = this, o = e.l / Math.sin(i.l), a = Math.max(e.r - n.width, 0) / Math.sin(i.r), s = -e.t / Math.cos(i.t), l = -Math.max(e.b - n.height, 0) / Math.cos(i.b); o = u(o), a = u(a), s = u(s), l = u(l), n.drawingArea = Math.min(Math.round(t - (o + a) / 2), Math.round(t - (s + l) / 2)), n.setCenterPoint(o, a, s, l) }, setCenterPoint: function (t, e, i, n) { var o = this, a = o.width - e - o.drawingArea, s = t + o.drawingArea, l = i + o.drawingArea, u = o.height - n - o.drawingArea; o.xCenter = Math.round((s + a) / 2 + o.left), o.yCenter = Math.round((l + u) / 2 + o.top) }, getIndexAngle: function (t) { var i = 2 * Math.PI / e(this); return t * i + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360 }, getDistanceFromCenterForValue: function (t) { if (null === t) return 0; var e = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - t) * e : (t - this.min) * e }, getPointPosition: function (t, e) { var i = this.getIndexAngle(t) - Math.PI / 2; return { x: Math.round(Math.cos(i) * e) + this.xCenter, y: Math.round(Math.sin(i) * e) + this.yCenter } }, getPointPositionForValue: function (t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) }, getBasePosition: function () { var t = this.min, e = this.max; return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0) }, draw: function () { var t = this, n = t.options, o = n.gridLines, u = n.ticks, h = c.getValueOrDefault; if (n.display) { var f = t.ctx, p = h(u.fontSize, d.defaultFontSize), $ = h(u.fontStyle, d.defaultFontStyle), m = h(u.fontFamily, d.defaultFontFamily), v = c.fontString(p, $, m); c.each(t.ticks, function (i, a) { if (a > 0 || n.reverse) { var s = t.getDistanceFromCenterForValue(t.ticksAsNumbers[a]), l = t.yCenter - s; if (o.display && 0 !== a && function t(i, n, o, a) { var s = i.ctx; if (s.strokeStyle = c.getValueAtIndexOrDefault(n.color, a - 1), s.lineWidth = c.getValueAtIndexOrDefault(n.lineWidth, a - 1), i.options.lineArc) s.beginPath(), s.arc(i.xCenter, i.yCenter, o, 0, 2 * Math.PI), s.closePath(), s.stroke(); else { var l = e(i); if (0 === l) return; s.beginPath(); var u = i.getPointPosition(0, o); s.moveTo(u.x, u.y); for (var d = 1; d < l; d++)u = i.getPointPosition(d, o), s.lineTo(u.x, u.y); s.closePath(), s.stroke() } }(t, o, s, a), u.display) { var $ = h(u.fontColor, d.defaultFontColor); if (f.font = v, u.showLabelBackdrop) { var m = f.measureText(i).width; f.fillStyle = u.backdropColor, f.fillRect(t.xCenter - m / 2 - u.backdropPaddingX, l - p / 2 - u.backdropPaddingY, m + 2 * u.backdropPaddingX, p + 2 * u.backdropPaddingY) } f.textAlign = "center", f.textBaseline = "middle", f.fillStyle = $, f.fillText(i, t.xCenter, l) } } }), n.lineArc || function t(n) { var o = n.ctx, u = c.getValueOrDefault, h = n.options, f = h.angleLines, p = h.pointLabels; o.lineWidth = f.lineWidth, o.strokeStyle = f.color; var $ = n.getDistanceFromCenterForValue(h.reverse ? n.min : n.max), m = i(n); o.textBaseline = "top"; for (var v = e(n) - 1; v >= 0; v--) { if (f.display) { var _ = n.getPointPosition(v, $); o.beginPath(), o.moveTo(n.xCenter, n.yCenter), o.lineTo(_.x, _.y), o.stroke(), o.closePath() } var x = n.getPointPosition(v, $ + 5), y = u(p.fontColor, d.defaultFontColor); o.font = m.font, o.fillStyle = y; var k = n.getIndexAngle(v), S = c.toDegrees(k); o.textAlign = a(S), l(S, n._pointLabelSizes[v], x), s(o, n.pointLabels[v] || "", x, m.size) } }(t) } } }); t.scaleService.registerScaleType("radialLinear", f, h) } }, {},], 48: [function (t, e, i) { "use strict"; var n = t(1); n = "function" == typeof n ? n : window.moment, e.exports = function (t) { var e = t.helpers, i = { units: [{ name: "millisecond", steps: [1, 2, 5, 10, 20, 50, 100, 250, 500] }, { name: "second", steps: [1, 2, 5, 10, 30] }, { name: "minute", steps: [1, 2, 5, 10, 30] }, { name: "hour", steps: [1, 2, 3, 6, 12] }, { name: "day", steps: [1, 2, 5] }, { name: "week", maxStep: 4 }, { name: "month", maxStep: 3 }, { name: "quarter", maxStep: 4 }, { name: "year", maxStep: !1 },] }, o = t.Scale.extend({ initialize: function () { if (!n) throw Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com"); t.Scale.prototype.initialize.call(this) }, getLabelMoment: function (t, e) { return null === t || null === e ? null : void 0 !== this.labelMoments[t] ? this.labelMoments[t][e] : null }, getLabelDiff: function (t, e) { return null === t || null === e ? null : (void 0 === this.labelDiffs && this.buildLabelDiffs(), void 0 !== this.labelDiffs[t] ? this.labelDiffs[t][e] : null) }, getMomentStartOf: function (t) { return "week" === this.options.time.unit && !1 !== this.options.time.isoWeekday ? t.clone().startOf("isoWeek").isoWeekday(this.options.time.isoWeekday) : t.clone().startOf(this.tickUnit) }, determineDataLimits: function () { var t = this; t.labelMoments = []; var i = []; t.chart.data.labels && t.chart.data.labels.length > 0 ? (e.each(t.chart.data.labels, function (e) { var n = t.parseTime(e); n.isValid() && (t.options.time.round && n.startOf(t.options.time.round), i.push(n)) }, t), t.firstTick = n.min.call(t, i), t.lastTick = n.max.call(t, i)) : (t.firstTick = null, t.lastTick = null), e.each(t.chart.data.datasets, function (o, a) { var s = [], l = t.chart.isDatasetVisible(a); "object" == typeof o.data[0] && null !== o.data[0] ? e.each(o.data, function (e) { var i = t.parseTime(t.getRightValue(e)); i.isValid() && (t.options.time.round && i.startOf(t.options.time.round), s.push(i), l && (t.firstTick = null !== t.firstTick ? n.min(t.firstTick, i) : i, t.lastTick = null !== t.lastTick ? n.max(t.lastTick, i) : i)) }, t) : s = i, t.labelMoments.push(s) }, t), t.options.time.min && (t.firstTick = t.parseTime(t.options.time.min)), t.options.time.max && (t.lastTick = t.parseTime(t.options.time.max)), t.firstTick = (t.firstTick || n()).clone(), t.lastTick = (t.lastTick || n()).clone() }, buildLabelDiffs: function () { var t = this; t.labelDiffs = []; var i = []; t.chart.data.labels && t.chart.data.labels.length > 0 && e.each(t.chart.data.labels, function (e) { var n = t.parseTime(e); n.isValid() && (t.options.time.round && n.startOf(t.options.time.round), i.push(n.diff(t.firstTick, t.tickUnit, !0))) }, t), e.each(t.chart.data.datasets, function (n) { var o = []; "object" == typeof n.data[0] && null !== n.data[0] ? e.each(n.data, function (e) { var i = t.parseTime(t.getRightValue(e)); i.isValid() && (t.options.time.round && i.startOf(t.options.time.round), o.push(i.diff(t.firstTick, t.tickUnit, !0))) }, t) : o = i, t.labelDiffs.push(o) }, t) }, buildTicks: function () { var n, o = this; o.ctx.save(); var a = e.getValueOrDefault(o.options.ticks.fontSize, t.defaults.global.defaultFontSize), s = e.getValueOrDefault(o.options.ticks.fontStyle, t.defaults.global.defaultFontStyle), l = e.getValueOrDefault(o.options.ticks.fontFamily, t.defaults.global.defaultFontFamily), u = e.fontString(a, s, l); if (o.ctx.font = u, o.ticks = [], o.unitScale = 1, o.scaleSizeInUnits = 0, o.options.time.unit) o.tickUnit = o.options.time.unit || "day", o.displayFormat = o.options.time.displayFormats[o.tickUnit], o.scaleSizeInUnits = o.lastTick.diff(o.firstTick, o.tickUnit, !0), o.unitScale = e.getValueOrDefault(o.options.time.unitStepSize, 1); else { var c, d = o.isHorizontal() ? o.width : o.height, h = o.tickFormatFunction(o.firstTick, 0, []), f = o.ctx.measureText(h).width, p = d / (f = f * Math.cos(e.toRadians(o.options.ticks.maxRotation)) + a * Math.sin(e.toRadians(o.options.ticks.maxRotation))); o.tickUnit = o.options.time.minUnit, o.scaleSizeInUnits = o.lastTick.diff(o.firstTick, o.tickUnit, !0), o.displayFormat = o.options.time.displayFormats[o.tickUnit]; for (var $ = 0, m = i.units[$]; $ < i.units.length;) { if (o.unitScale = 1, e.isArray(m.steps) && Math.ceil(o.scaleSizeInUnits / p) < e.max(m.steps)) { for (var v = 0; v < m.steps.length; ++v)if (m.steps[v] >= Math.ceil(o.scaleSizeInUnits / p)) { o.unitScale = e.getValueOrDefault(o.options.time.unitStepSize, m.steps[v]); break } break } if (!1 === m.maxStep || Math.ceil(o.scaleSizeInUnits / p) < m.maxStep) { o.unitScale = e.getValueOrDefault(o.options.time.unitStepSize, Math.ceil(o.scaleSizeInUnits / p)); break } ++$, m = i.units[$], o.tickUnit = m.name; var _ = o.firstTick.diff(o.getMomentStartOf(o.firstTick), o.tickUnit, !0), x = o.getMomentStartOf(o.lastTick.clone().add(1, o.tickUnit)).diff(o.lastTick, o.tickUnit, !0); o.scaleSizeInUnits = o.lastTick.diff(o.firstTick, o.tickUnit, !0) + _ + x, o.displayFormat = o.options.time.displayFormats[m.name] } } if (o.options.time.min ? n = o.getMomentStartOf(o.firstTick) : (o.firstTick = o.getMomentStartOf(o.firstTick), n = o.firstTick), !o.options.time.max) { var y = o.getMomentStartOf(o.lastTick), k = y.diff(o.lastTick, o.tickUnit, !0); k < 0 ? o.lastTick = o.getMomentStartOf(o.lastTick.add(1, o.tickUnit)) : k >= 0 && (o.lastTick = y), o.scaleSizeInUnits = o.lastTick.diff(o.firstTick, o.tickUnit, !0) } o.options.time.displayFormat && (o.displayFormat = o.options.time.displayFormat), o.ticks.push(o.firstTick.clone()); for (var S = o.unitScale; S <= o.scaleSizeInUnits; S += o.unitScale) { var w = n.clone().add(S, o.tickUnit); if (o.options.time.max && w.diff(o.lastTick, o.tickUnit, !0) >= 0) break; o.ticks.push(w) } 0 === o.ticks[o.ticks.length - 1].diff(o.lastTick, o.tickUnit) && 0 !== o.scaleSizeInUnits || (o.options.time.max ? (o.ticks.push(o.lastTick.clone()), o.scaleSizeInUnits = o.lastTick.diff(o.ticks[0], o.tickUnit, !0)) : (o.ticks.push(o.lastTick.clone()), o.scaleSizeInUnits = o.lastTick.diff(o.firstTick, o.tickUnit, !0))), o.ctx.restore(), o.labelDiffs = void 0 }, getLabelForIndex: function (t, e) { var i = this.chart.data.labels && t < this.chart.data.labels.length ? this.chart.data.labels[t] : "", n = this.chart.data.datasets[e].data[t]; return null !== n && "object" == typeof n && (i = this.getRightValue(n)), this.options.time.tooltipFormat && (i = this.parseTime(i).format(this.options.time.tooltipFormat)), i }, tickFormatFunction: function (t, i, n) { var o = t.format(this.displayFormat), a = this.options.ticks, s = e.getValueOrDefault(a.callback, a.userCallback); return s ? s(o, i, n) : o }, convertTicksToLabels: function () { var t = this; t.tickMoments = t.ticks, t.ticks = t.ticks.map(t.tickFormatFunction, t) }, getPixelForValue: function (t, e, i) { var n = null; if (void 0 !== e && void 0 !== i && (n = this.getLabelDiff(i, e)), null === n && (t && t.isValid || (t = this.parseTime(this.getRightValue(t))), t && t.isValid && t.isValid() && (n = t.diff(this.firstTick, this.tickUnit, !0))), null !== n) { var o = 0 !== n ? n / this.scaleSizeInUnits : n; if (this.isHorizontal()) { var a = this.width * o; return this.left + Math.round(a) } var s = this.height * o; return this.top + Math.round(s) } }, getPixelForTick: function (t) { return this.getPixelForValue(this.tickMoments[t], null, null) }, getValueForPixel: function (t) { var e = this.isHorizontal() ? this.width : this.height, i = (t - (this.isHorizontal() ? this.left : this.top)) / e; return i *= this.scaleSizeInUnits, this.firstTick.clone().add(n.duration(i, this.tickUnit).asSeconds(), "seconds") }, parseTime: function (t) { return "string" == typeof this.options.time.parser ? n(t, this.options.time.parser) : "function" == typeof this.options.time.parser ? this.options.time.parser(t) : "function" == typeof t.getMonth || "number" == typeof t ? n(t) : t.isValid && t.isValid() ? t : "string" != typeof this.options.time.format && this.options.time.format.call ? (console.warn("options.time.format is deprecated and replaced by options.time.parser. See http://nnnick.github.io/Chart.js/docs-v2/#scales-time-scale"), this.options.time.format(t)) : n(t, this.options.time.format) } }); t.scaleService.registerScaleType("time", o, { position: "bottom", time: { parser: !1, format: !1, unit: !1, round: !1, displayFormat: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: { millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm:ss a", hour: "MMM D, hA", day: "ll", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY" } }, ticks: { autoSkip: !1 } }) } }, { 1: 1 },] }, {}, [7])(7) });